# -*- coding: utf-8 -*-
"""ml project(200 marks).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1itfgfgnc15IEjm0yClOcMu-CktLRkae6

# üìò Dataset Description

### **Optimized for Black-Litterman, Entropy, ESG, and Game Theory-Based Portfolio Models**

This dataset presents curated financial data from a selection of high-quality **Indian listed companies**, structured specifically to support advanced financial modeling and portfolio optimization techniques. Each data point is selected to integrate seamlessly into models that utilize:

* **üß† Black-Litterman Model** ‚Äì for blending market equilibrium with subjective investor views
* **‚ôªÔ∏è Entropy-Based Allocation** ‚Äì to ensure diversification and reduce portfolio concentration risk
* **üå± ESG Factors** ‚Äì for sustainability-aligned investment strategies
* **üéØ Game Theory** ‚Äì for modeling strategic interaction between assets or market regimes

---

### üìÇ Columns and Their Meaning:

| Column Name        | Description                                                           |
| ------------------ | --------------------------------------------------------------------- |
| `Name`             | Company name (e.g., HDFC Bank, Tata Motors, Nestle India)             |
| `P/E`              | **Price-to-Earnings Ratio** ‚Äì Market valuation multiple               |
| `Div Yld %`        | **Dividend Yield (%)** ‚Äì Returns through dividends                    |
| `NP Qtr Rs.Cr.`    | **Quarterly Net Profit (‚Çπ Crores)** ‚Äì Indicator of profitability      |
| `Qtr Profit Var %` | **Quarterly Profit Growth (%)** ‚Äì Performance trend over last quarter |
| `Sales Qtr Rs.Cr.` | **Quarterly Revenue (‚Çπ Crores)** ‚Äì Top-line business performance      |
| `Qtr Sales Var %`  | **Sales Growth (%)** ‚Äì Change in revenue compared to previous quarter |

---

### üßÆ Strategic Use Cases

| Modeling Focus              | Relevant Columns                          | Role in Modeling                                              |
| --------------------------- | ----------------------------------------- | ------------------------------------------------------------- |
| **Valuation Analysis**      | `P/E`, `Div Yld %`                        | To identify undervalued or overvalued stocks                  |
| **Profitability Metrics**   | `NP Qtr Rs.Cr.`, `Qtr Profit Var %`       | Used in alpha signal generation and view modeling (BL model)  |
| **Growth Analysis**         | `Sales Qtr Rs.Cr.`, `Qtr Sales Var %`     | Momentum or fundamental growth factor                         |
| **Entropy Diversification** | All numerical columns                     | Entropy calculated from normalized distributions              |
| **ESG Scoring (Proxy)**     | `Div Yld %`, Profit & Growth metrics      | Sustainability-linked performance indicators                  |
| **Game Theory Input**       | Cross-company matrices of returns & risks | Construct payoff matrices to optimize strategic asset weights |
| **Black-Litterman Views**   | Returns & Growth Data                     | Integrates subjective views with market equilibrium           |

---

### ‚úÖ Ideal For:

* üéØ **Modern Portfolio Optimization**
* üìà **Smart Beta & Factor Investing**
* üåç **Sustainable ESG-Aligned Portfolios**
* üîê **Entropy-Based Risk Management**
* üé≤ **Game Theory-Based Strategic Allocation**
* üß† **Bayesian Modeling via Black-Litterman**

Portfolio optimization is a crucial task in finance aimed at maximizing returns while managing risk through the strategic allocation of assets. Modern advancements have enabled the integration of diverse methodologies and data-driven approaches to enhance portfolio construction, among which machine learning (ML) stands out by harnessing complex data patterns for better decision-making. A comprehensive ML model for portfolio optimization can combine several sophisticated methods‚ÄîBlack-Litterman, Environmental, Social, and Governance (ESG) analysis, entropy-based diversification, and game theory‚Äîto create a robust, adaptive, and responsible investment strategy. The Black-Litterman model enriches traditional mean-variance optimization by blending market equilibrium with investor views, thereby producing more stable and calibrated expected returns that reflect both market consensus and subjective insights. Incorporating ESG factors ensures that the portfolio aligns with sustainability and ethical standards, addressing the growing market demand for responsible investments and mitigating long-term risks linked to environmental, social, and governance issues. Entropy-based methods contribute by quantifying diversification and uncertainty within portfolio weights, encouraging a well-balanced allocation that avoids concentration risk while adapting to changing market dynamics. Finally, game theory adds a strategic dimension by modeling the interactions between multiple market participants or competing assets, seeking equilibrium solutions that optimize returns considering competitive behaviors and market impact. Together, these approaches enable an ML-enhanced portfolio optimization framework that balances risk, return, diversification, sustainability, and strategic interaction to achieve superior and resilient investment performance in complex financial markets.
"""

pip install PyPortfolioOpt

!pip install nashpy

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.feature_selection import mutual_info_classif
from pypfopt import EfficientFrontier, risk_models, expected_returns
from pypfopt.black_litterman import BlackLittermanModel
from sklearn.tree import DecisionTreeClassifier
import math
from scipy.optimize import minimize

import nashpy as nash

import yfinance as yf

# List of stock symbols
tickers = {
    ## large cap stocks
    "TCS": "TCS.NS",
    "Infosys": "INFY.NS",
    "HDFC Bank": "HDFCBANK.NS",
    "ICICI Bank": "ICICIBANK.NS",
    "Kotak Mah. Bank": "KOTAKBANK.NS",
    "Hind. Unilever": "HINDUNILVR.NS",
    "ITC": "ITC.NS",
    "Nestle India": "NESTLEIND.NS",
    "Asian Paints": "ASIANPAINT.NS",
    "Tata Steel": "TATASTEEL.NS",
    "Tata Motors": "TATAMOTORS.NS",
    "Maruti Suzuki": "MARUTI.NS",
    "Reliance Industr": "RELIANCE.NS",
    "Adani Green": "ADANIGREEN.NS",
    "Power Grid Corpn": "POWERGRID.NS",
    "L&T Finance Ltd": "LTF.NS",
    "Larsen & Toubro": "LT.NS",
    "DLF": "DLF.NS",
    "Lodha Developers": "LODHA.NS",
    "Godrej Propert.": "GODREJPROP.NS",

    # mid cap stocks
    "Hindustan Zinc Ltd": "HINDZINC.NS",
    "Solar Industries India Ltd": "SOLARINDS.NS",
    "Mazagon Dock Shipbuilders Ltd": "MAZDOCK.NS",
    "Max Healthcare Institute Ltd": "MAXHEALTH.NS",
    "HDFC Asset Management Company Ltd": "HDFCAMC.NS",
    "Union Bank of India Ltd": "UNIONBANK.NS",
    "Mankind Pharma Ltd": "MANKIND.NS",
    "Indus Towers Ltd": "INDUSTOWER.NS",
    "Muthoot Finance Ltd": "MUTHOOTFIN.NS",
    "Polycab India Ltd": "POLYCAB.NS",

    # Small-cap stocks
    "Indian Energy Exchange Ltd": "IEX.NS",
    "Central Depository Services (India) Ltd": "CDSL.NS",
    "Aptus Value Housing Finance India Ltd": "APTUS.NS",
    "Five-Star Business Finance Ltd": "FIVESTAR.NS",
    "Clean Science and Technology Ltd": "CLEAN.NS"

}

import yfinance as yf
import pandas as pd
import numpy as np
import random
from scipy.optimize import minimize



def esg_decision(score):
    if score >= 0.7:
        return "BUY"
    elif score >= 0.4:
        return "HOLD"
    else:
        return "SELL"


def calculate_peg(symbol):
    try:
        stock = yf.Ticker(symbol)
        info = stock.info
        pe_ratio = info.get("trailingPE", np.nan)
        eps_ttm = info.get("trailingEps", np.nan)

        # Estimate growth rate using EPS history
        fin = stock.quarterly_earnings
        if fin is not None and len(fin) >= 2:
            eps_growth = ((fin["Earnings"].iloc[-1] - fin["Earnings"].iloc[-2]) /
                          abs(fin["Earnings"].iloc[-2])) * 100
        else:
            eps_growth = np.nan

        if pe_ratio and eps_growth and eps_growth != 0:
            peg = pe_ratio / eps_growth
        else:
            peg = np.nan

        return pe_ratio, eps_growth, peg
    except Exception as e:
        print(f"PEG error for {symbol}: {e}")
        return np.nan, np.nan, np.nan

# -----------------------------
# 4. Black-Litterman, Entropy, Game-Theory (simplified)
# -----------------------------
def black_litterman(cov, pi, P, Q, tau=0.05, omega=None):
    if omega is None:
        omega = np.diag(np.diag(P @ cov @ P.T)) * tau
    M = np.linalg.inv(np.linalg.inv(tau * cov) + P.T @ np.linalg.inv(omega) @ P)
    adj_return = M @ (np.linalg.inv(tau * cov) @ pi + P.T @ np.linalg.inv(omega) @ Q)
    return adj_return

def entropy_obj(w, mu, cov, lam=0.1):
    w = np.array(w)
    ret = w @ mu
    risk = w @ cov @ w
    entropy = -np.sum(w * np.log(w + 1e-9))
    return -(ret - lam * risk + 0.01 * entropy)

def nash_bargaining(mu, cov, esg_scores):
    n = len(mu)
    init_w = np.ones(n) / n
    cons = ({'type': 'eq', 'fun': lambda w: np.sum(w) - 1})
    bounds = [(0, 1)] * n

    def utility(w):
        ret = w @ mu
        risk = w @ cov @ w
        esg = np.sum(w * esg_scores)
        return -(np.log(ret + 1e-9) + np.log(esg + 1e-9) - np.log(risk + 1e-9))

    res = minimize(utility, init_w, constraints=cons, bounds=bounds)
    return res.x if res.success else init_w


def run_portfolio():
    data = yf.download(list(tickers.values()), period="1y")["Close"].dropna()
    log_ret = np.log(data / data.shift(1)).dropna()
    mu = log_ret.mean().values * 252
    cov = log_ret.cov().values * 252

    esg_scores = np.array([round(random.uniform(0, 1), 2) for _ in range(len(tickers))])
    pi = mu
    P = np.array([[0,1,0,0,0,0,0,0,0,0,0,0,1] + [0]*(len(tickers)-13)])
    Q = np.array([0.15])
    bl_mu = black_litterman(cov, pi, P, Q)

    n = len(mu)
    init_w = np.ones(n) / n
    cons = ({'type': 'eq', 'fun': lambda w: np.sum(w) - 1})
    bounds = [(0, 1)] * n
    res = minimize(entropy_obj, init_w, args=(bl_mu, cov), constraints=cons, bounds=bounds)
    entropy_weights = res.x if res.success else init_w
    gt_weights = nash_bargaining(bl_mu, cov, esg_scores)
    final_weights = 0.5 * entropy_weights + 0.5 * gt_weights

    pegs, pe_ratios, growths = [], [], []
    for sym in tickers.values():
        pe, growth, peg = calculate_peg(sym)
        pe_ratios.append(pe)
        growths.append(growth)
        pegs.append(peg)

    df = pd.DataFrame({
        "Stock": list(tickers.keys()),
        "Symbol": list(tickers.values()),
        "ESG Score": esg_scores,
        "BL Expected Return": bl_mu,
        "Entropy Wt": entropy_weights,
        "Game Theory Wt": gt_weights,
        "Final Wt": final_weights,
        "P/E Ratio": pe_ratios,
        "Earnings Growth (%)": growths,
        "PEG Ratio": pegs
    })

    df["Decision"] = df["ESG Score"].apply(esg_decision)
    return df.sort_values(by="Final Wt", ascending=False)

# -----------------------------
# Run Once
# -----------------------------
if __name__ == "__main__":
    portfolio = run_portfolio()
    print("\n=== Optimized Portfolio with PEG Ratio ===")
    print(portfolio.head(15))

pip install pandas yfinance openpyxl

import yfinance as yf
import pandas as pd
import numpy as np
import time
import requests
from bs4 import BeautifulSoup
from datetime import datetime
from IPython.display import clear_output, display
import requests
import numpy as np
import pandas as pd
import yfinance as yf
from bs4 import BeautifulSoup
from datetime import datetime
import time
from IPython.display import clear_output, display

import requests
import yfinance as yf
import pandas as pd
import numpy as np
import time
from bs4 import BeautifulSoup
from datetime import datetime
from IPython.display import clear_output

# --- SCRAPER: Screener data ---
def fetch_screener_data(symbol_short):
    url = f"https://www.screener.in/company/{symbol_short}/consolidated/"
    headers = {"User-Agent": "Mozilla/5.0"}

    try:
        resp = requests.get(url, headers=headers, timeout=10)
        resp.raise_for_status()
        soup = BeautifulSoup(resp.text, "html.parser")
    except requests.RequestException as e:
        print(f"Error fetching data for {symbol_short}: {e}")
        return {field: np.nan for field in [
            "Promoter Holding %", "ROCE %", "ROE %", "Debt/Equity",
            "Qtr Profit Var %", "Qtr Sales Var %"
        ]}

    data = {}
    for field, label in [
        ("Promoter Holding %", ("Promoter holding", "%")),
        ("ROCE %", ("ROCE", "%")),
        ("ROE %", ("ROE %", "%")),
        ("Debt/Equity", ("Debt / Eq", "")),
        ("Qtr Profit Var %", ("Qtr Profit Var %", "%")),
        ("Qtr Sales Var %", ("Qtr Sales Var %", "%"))
    ]:
        try:
            cell = soup.find(text=label[0]).find_next("td").text.strip()
            val = cell.replace("%", "").replace(",", "")
            data[field] = float(val)
        except (AttributeError, ValueError):
            data[field] = np.nan

    return data


# --- ESG SCORE ---
def compute_esg(debt_equity, prom_hold):
    try:
        e = 1 - (debt_equity / (debt_equity + 1))
        g = prom_hold / 100
        return round((e + g) / 2, 3)
    except ZeroDivisionError:
        return np.nan


# --- PEG RATIO ---
def compute_peg(pe_ratio, growth_rate):
    """
    PEG = PE Ratio / Earnings Growth (%)
    """
    try:
        if growth_rate and growth_rate != 0:
            return round(pe_ratio / growth_rate, 3)
        else:
            return np.nan
    except (TypeError, ZeroDivisionError):
        return np.nan


# --- MAIN LOOP ---
for _ in range(5):
    all_symbols = list(tickers.values())
    price_data = yf.download(
        all_symbols,
        period="1d",
        interval="5m",
        group_by='ticker',
        auto_adjust=True,
        progress=False
    )

    rows = []
    for idx, (name, symbol) in enumerate(tickers.items(), 1):
        try:
            price = price_data[symbol].iloc[-1]['Close']
        except (KeyError, IndexError):
            price = np.nan

        info = yf.Ticker(symbol).info
        pe = info.get("trailingPE", np.nan)
        mc = info.get("marketCap", np.nan) / 1e7 if info.get("marketCap") else np.nan
        div_yield = info.get("dividendYield", np.nan) * 100 if info.get("dividendYield") else np.nan
        np_qtr = info.get("netIncomeToCommon", np.nan) / 1e7 if info.get("netIncomeToCommon") else np.nan
        sales_qtr = info.get("totalRevenue", np.nan) / 1e7 if info.get("totalRevenue") else np.nan

        short_sym = symbol.split('.')[0]
        scraped = fetch_screener_data(short_sym)

        esg = compute_esg(scraped["Debt/Equity"], scraped["Promoter Holding %"])
        peg = compute_peg(pe, scraped["Qtr Profit Var %"])

        rows.append([
            idx, name, symbol, price, pe, mc, div_yield, np_qtr, sales_qtr,
            scraped["Qtr Profit Var %"], scraped["Qtr Sales Var %"], esg, peg
        ])

    df = pd.DataFrame(rows, columns=[
        "S.No.", "Name", "Symbol", "CMP Rs.", "P/E", "Market Cap Rs.Cr.",
        "Div Yld %", "NP Qtr Rs.Cr.", "Sales Qtr Rs.Cr.",
        "Qtr Profit Var %", "Qtr Sales Var %", "ESG Score", "PEG Ratio"
    ])

    styled = df.style.format({
        "CMP Rs.": "{:.2f}",
        "P/E": "{:.2f}",
        "Market Cap Rs.Cr.": "{:.2f}",
        "Div Yld %": "{:.2f}",
        "NP Qtr Rs.Cr.": "{:.2f}",
        "Sales Qtr Rs.Cr.": "{:.2f}",
        "Qtr Profit Var %": "{:.2f}",
        "Qtr Sales Var %": "{:.2f}",
        "ESG Score": "{:.3f}",
        "PEG Ratio": "{:.3f}"
    }, na_rep="-")

    clear_output(wait=True)
    print(f"üìä Last updated: {datetime.now().strftime('%H:%M:%S')}")
    display(styled)

    time.sleep(60)

def fetch_screener_data(symbol_short):
    url = f"https://www.screener.in/company/{symbol_short}/consolidated/"
    headers = {"User-Agent": "Mozilla/5.0"}

    try:
        resp = requests.get(url, headers=headers, timeout=10)
        resp.raise_for_status()
        soup = BeautifulSoup(resp.text, "html.parser")
    except requests.RequestException as e:
        print(f"Error fetching data for {symbol_short}: {e}")
        return {field: np.nan for field in [
            "Promoter Holding %", "ROCE %", "ROE %", "Debt/Equity", "Qtr Profit Var %", "Qtr Sales Var %"
        ]}

    data = {}
    for field, label in [
        ("Promoter Holding %", ("Promoter holding", "%")),
        ("ROCE %", ("ROCE", "%")),
        ("ROE %", ("ROE %", "%")),
        ("Debt/Equity", ("Debt / Eq", "")),
        ("Qtr Profit Var %", ("Qtr Profit Var %", "%")),
        ("Qtr Sales Var %", ("Qtr Sales Var %", "%"))
    ]:
        try:
            cell = soup.find(text=label[0]).find_next("td").text.strip()
            val = cell.replace("%", "").replace(",", "")
            data[field] = float(val)
        except (AttributeError, ValueError):
            data[field] = np.nan

    return data


def compute_esg(debt_equity, prom_hold):
    try:
        e = 1 - (debt_equity / (debt_equity + 1))
        g = prom_hold / 100
        return round((e + g) / 2, 3)
    except ZeroDivisionError:
        return np.nan


for _ in range(5):
    all_symbols = list(tickers.values())
    price_data = yf.download(all_symbols, period="1d", interval="5m",
                             group_by='ticker', auto_adjust=True, progress=False)

    rows = []
    for idx, (name, symbol) in enumerate(tickers.items(), 1):
        try:
            price = price_data[symbol].iloc[-1]['Close']
        except (KeyError, IndexError):
            price = np.nan

        info = yf.Ticker(symbol).info
        pe = info.get("trailingPE", np.nan)
        mc = info.get("marketCap", np.nan) / 1e7 if info.get("marketCap") else np.nan
        div_yield = info.get("dividendYield", np.nan) * 100 if info.get("dividendYield") else np.nan
        np_qtr = info.get("netIncomeToCommon", np.nan) / 1e7 if info.get("netIncomeToCommon") else np.nan
        sales_qtr = info.get("totalRevenue", np.nan) / 1e7 if info.get("totalRevenue") else np.nan

        short_sym = symbol.split('.')[0]
        scraped = fetch_screener_data(short_sym)

        esg = compute_esg(scraped["Debt/Equity"], scraped["Promoter Holding %"])

        rows.append([idx, name, symbol, price, pe, mc, div_yield, np_qtr, sales_qtr, esg])

    df = pd.DataFrame(rows, columns=[
        "S.No.", "Name", "Symbol", "CMP Rs.", "P/E", "Market Cap Rs.Cr.",
        "Div Yld %", "NP Qtr Rs.Cr.", "Sales Qtr Rs.Cr.", "ESG Score"
    ])

    styled = df.style.format({
        "CMP Rs.": "{:.2f}", "P/E": "{:.2f}", "Market Cap Rs.Cr.": "{:.2f}",
        "Div Yld %": "{:.2f}", "NP Qtr Rs.Cr.": "{:.2f}", "Sales Qtr Rs.Cr.": "{:.2f}", "ESG Score": "{:.3f}"
    }, na_rep="-")

    clear_output(wait=True)
    print(f"Last updated: {datetime.now().strftime('%H:%M:%S')}")
    display(styled)

    time.sleep(60)

plt.figure(figsize=(12,6))
sns.barplot(data=df, x="Name", y="Market Cap Rs.Cr.")
plt.xticks(rotation=45, ha='right')
plt.title("Market Cap of Companies")
plt.show()

import matplotlib.pyplot as plt

plt.figure(figsize=(8,4))
scatter = plt.scatter(
    df["Sales Qtr Rs.Cr."],
    df["NP Qtr Rs.Cr."],
    s=df["Market Cap Rs.Cr."]/50,   # adjust divisor for bubble scaling
    alpha=0.5,                      # transparency
    edgecolors="k",                 # black border for clarity
    linewidth=0.5,
    c=df["Market Cap Rs.Cr."],      # color by market cap
    cmap="viridis"                  # nice color map
)

# Only annotate top companies (e.g., top 10 by Market Cap)
top_companies = df.nlargest(10, "Market Cap Rs.Cr.")
for i, row in top_companies.iterrows():
    plt.annotate(
        row["Name"],
        (row["Sales Qtr Rs.Cr."], row["NP Qtr Rs.Cr."]),
        fontsize=9,
        ha="center"
    )

plt.xlabel("Quarterly Sales (Rs. Cr.)")
plt.ylabel("Quarterly Profit (Rs. Cr.)")
plt.title("Sales vs Profit (Bubble size = Market Cap)", fontsize=14, weight="bold")
plt.colorbar(scatter, label="Market Cap (Rs. Cr.)")  # color legend
plt.tight_layout()
plt.show()

"""## What is a correlation matrix?

A correlation matrix shows how strongly two variables move together.

Correlation values range between:

+1 ‚Üí Perfect positive correlation (they move together).

-1 ‚Üí Perfect negative correlation (they move in opposite directions).

0 ‚Üí No linear relationship.

In this chart:

Redder areas (close to +1) ‚Üí strong positive relationship.

Bluer areas (close to -1) ‚Üí strong negative relationship.

Lighter areas (close to 0) ‚Üí weak or no relationship.

üîπ Interpretation of Your Chart

Market Cap vs NP (Net Profit) Qtr (0.94)

Very high positive correlation.

Larger companies (higher market cap) tend to report higher quarterly profits.

Market Cap vs Sales Qtr (0.78)

Strong positive correlation.

Bigger firms generally have higher quarterly sales.

NP Qtr vs Sales Qtr (0.80)

Strong positive correlation.

Companies with higher sales also show higher net profits (makes sense operationally).

P/E vs Div Yld (-0.39)

Moderate negative correlation.

Higher P/E ratio companies (growth stocks) usually pay lower dividends, while lower P/E (value stocks) often pay higher dividends.

Market Cap vs P/E (-0.24)

Slight negative correlation.

Larger companies might not always have high growth expectations (hence lower P/E).

S.No. (serial number column)

Not meaningful ‚Äî it‚Äôs just an index number from your dataset, so correlations with it don‚Äôt carry business meaning.

ESG Score

Appears blank (no data in your dataset), so it wasn‚Äôt included in correlation calculations.
"""

corr = df.drop(columns=["S.No."]).corr(numeric_only=True)

plt.figure(figsize=(10,6))
sns.heatmap(corr, annot=True, cmap="coolwarm", fmt=".2f")
plt.title("Correlation Matrix of Financial Metrics")
plt.show()

price_data['TCS.NS']['Close'].plot(figsize=(10,5), title="TCS Stock Price Trend")
plt.ylabel("Price (Rs.)")
plt.show()

import matplotlib.pyplot as plt

price_data['INFY.NS']['Close'].plot(
    figsize=(10, 5),
    title="Infosys Stock Price Trend",
    color='lightblue'   # try 'red', 'green', 'orange', etc.
)
plt.ylabel("Price (Rs.)")
plt.show()

price_data['HDFCBANK.NS']['Close'].plot(figsize=(10,5), title="HDFC Stock Price Trend")
plt.ylabel("Price (Rs.)")
plt.show()

plt.figure(figsize=(10,6))
sns.barplot(data=df, y="Name", x="Div Yld %", palette="viridis")
plt.title("Dividend Yield by Company")
plt.show()

plt.figure(figsize=(8,6))
sns.boxplot(data=df, x="P/E")
plt.title("Distribution of P/E Ratios")
plt.show()

df_plot = df[["Name", "Sales Qtr Rs.Cr.", "NP Qtr Rs.Cr."]].set_index("Name")
df_plot.plot(kind="bar", stacked=True, figsize=(12,6))
plt.title("Quarterly Sales & Profit")
plt.ylabel("Rs. Cr.")
plt.show()

sns.pairplot(df[["P/E", "CMP Rs.", "Market Cap Rs.Cr.", "Div Yld %"]], diag_kind="kde")
plt.suptitle("Pairwise Relationships", y=1.02)
plt.show()

from math import pi

categories = ["P/E", "Div Yld %", "ESG Score", "NP Qtr Rs.Cr.", "Sales Qtr Rs.Cr."]
N = len(categories)

values = df.iloc[0][categories].values.flatten().tolist()
values += values[:1]  # repeat first value

angles = [n / float(N) * 2 * pi for n in range(N)]
angles += angles[:1]

plt.figure(figsize=(6,6))
ax = plt.subplot(111, polar=True)
plt.xticks(angles[:-1], categories)

ax.plot(angles, values, linewidth=2, linestyle="solid", label=df.iloc[0]["Name"])
ax.fill(angles, values, alpha=0.25)
plt.title(f"Radar Chart for {df.iloc[0]['Name']}")
plt.legend()
plt.show()

# Commented out IPython magic to ensure Python compatibility.
# %pip install squarify

import matplotlib.pyplot as plt
import squarify  # pip install squarify

# Sort companies by market cap (biggest first)
df_sorted = df.sort_values("Market Cap Rs.Cr.", ascending=False)

# Plot treemap
plt.figure(figsize=(14,8))
squarify.plot(
    sizes=df_sorted["Market Cap Rs.Cr."],
    label=[name if cap > df_sorted["Market Cap Rs.Cr."].quantile(0.75) else ""
           for name, cap in zip(df_sorted["Name"], df_sorted["Market Cap Rs.Cr."])],  # only top labels
    alpha=0.8,
    color=plt.cm.viridis(df_sorted["Market Cap Rs.Cr."] / df_sorted["Market Cap Rs.Cr."].max()),
    text_kwargs={'fontsize':10, 'weight':'bold'}
)

plt.title("Treemap of Market Cap", fontsize=16, weight="bold")
plt.axis("off")
plt.show()

sectors = {}
for symbol in tickers.values():
    info = yf.Ticker(symbol).info
    sectors[symbol] = info.get("sector", "Unknown")


df["Sector"] = df["Symbol"].map(sectors)

sectors

plt.figure(figsize=(10,6))
sns.barplot(data=df, x="Sector", y="P/E", estimator="mean", ci=None, palette="Set2")
plt.title("Average P/E by Sector")
plt.xticks(rotation=45)
plt.show()

sector_mc = df.groupby("Sector")["Market Cap Rs.Cr."].sum().reset_index()
plt.figure(figsize=(10,6))
sns.barplot(data=sector_mc, x="Sector", y="Market Cap Rs.Cr.", palette="viridis")
plt.title("Total Market Cap by Sector")
plt.xticks(rotation=45)
plt.show()

"""This is a **bar chart** depicting the **total market capitalization by sector** in crores of rupees (Rs. Cr.).

## Chart Overview
- The x-axis lists different **market sectors**: Basic Materials, Communication Services, Consumer Cyclical, Consumer Defensive, Energy, Financial Services, Healthcare, Industrials, Real Estate, Technology, and Utilities.
- The y-axis represents **market cap** in crores of rupees, with a scale up to about 3.3 million Rs. Cr.
- Each vertical bar's height indicates the total market cap of that sector.

## Key Insights
- **Financial Services** dominates with the highest total market cap, well above 3 million Rs. Cr., reflecting its massive scale in the Indian market.
- **Technology** and **Energy** sectors also have substantial market caps, each exceeding 1.5 million Rs. Cr.
- **Consumer Defensive** and **Industrials** are mid-range, while **Communication Services** has the lowest total market cap among the sectors displayed.
- **Healthcare** and **Real Estate** exhibit relatively modest market caps.

## Interpretation Tips
- This visualization highlights the **relative size and importance of sectors** within the stock market, underscoring the dominance of the financial and technology sectors in India.
- Sectors with larger bars attract more investor capital and can have greater influence on overall market performance.

"""

plt.figure(figsize=(10,6))
sns.boxplot(data=df, x="Sector", y="Div Yld %", palette="coolwarm")
plt.title("Dividend Yield Distribution by Sector")
plt.xticks(rotation=45)
plt.show()

plt.figure(figsize=(12,6))
sns.heatmap(df.groupby("Sector").mean(numeric_only=True).T, annot=True, cmap="coolwarm")
plt.title("Sector-wise Average Metrics")
plt.show()

import squarify
sector_mc = df.groupby("Sector")["Market Cap Rs.Cr."].sum()

plt.figure(figsize=(12,7))
squarify.plot(sizes=sector_mc.values, label=sector_mc.index, alpha=0.7)
plt.title("Market Cap Distribution by Sector")
plt.axis("off")
plt.show()

plt.figure(figsize=(12,6))
sns.swarmplot(data=df, x="Sector", y="P/E", size=8, palette="husl")
plt.title("P/E Spread Across Sectors")
plt.xticks(rotation=45)
plt.show()

from math import pi

metrics = ["P/E", "Div Yld %", "ESG Score"]
sector_avg = df.groupby("Sector")[metrics].mean()

N = len(metrics)
angles = [n / float(N) * 2 * pi for n in range(N)] + [0]

plt.figure(figsize=(8,8))
for sector in sector_avg.index:
    values = sector_avg.loc[sector].tolist()
    values += values[:1]
    plt.polar(angles, values, label=sector)
plt.xticks(angles[:-1], metrics)
plt.title("Radar Chart of Sector Averages")
plt.legend(loc="upper right", bbox_to_anchor=(1.2, 1))
plt.show()

plt.figure(figsize=(12,6))
sns.violinplot(data=df, x="Sector", y="NP Qtr Rs.Cr.", palette="muted")
plt.title("Quarterly Profit Distribution by Sector")
plt.xticks(rotation=45)
plt.show()

"""The code shown creates a **facet grid of scatter plots** using Seaborn, displaying the relationship between **quarterly sales** and **quarterly net profit** for each sector, with companies differentiated by color.[1]

## Code Functionality
- **FacetGrid**: Splits the data (`df`) into separate scatter plots ("facets") for each unique value in the `"Sector"` column, laying them out in a grid with 3 columns per row, each facet having a height of 4 inches.
- **Scatter Plot**: For each sector, a scatter plot is drawn with:
  - **x-axis**: `"Sales Qtr Rs.Cr."` (quarterly sales in crores)
  - **y-axis**: `"NP Qtr Rs.Cr."` (quarterly net profit in crores)
  - **hue**: `"Name"` assigns different colors to data points from different companies within the sector.
- **Legend**: `g.add_legend()` adds a legend showing which color represents which company.
- **plt.show()**: Displays the entire grid of plots.

## Expected Output
- The final visualization consists of multiple scatter plots, one for each sector, arranged in a grid.
- In each plot, every dot represents a company‚Äôs quarterly sales and profit, colored by company name. This allows segment-wise comparison of sales/profit dynamics and quickly reveals sectors or firms with outlier performance.

## Interpretation Tips
- Use these charts to analyze how **sales and profits relate within and across sectors**.
- Outliers or distinct trends within specific sectors will be easy to spot, and company-level performance variation is visually clear by the color coding.

"""

g = sns.FacetGrid(df, col="Sector", col_wrap=3, height=4)
g.map_dataframe(sns.scatterplot, x="Sales Qtr Rs.Cr.", y="NP Qtr Rs.Cr.", hue="Name")
g.add_legend()
plt.show()

"""## Black Litter-man

## Black-Litterman Portfolio Model

The Black-Litterman portfolio model is a sophisticated asset allocation model developed by Fischer Black and Robert Litterman at Goldman Sachs. It blends investor views with market equilibrium (the CAPM-implied returns), addressing some limitations of traditional mean-variance optimization.

Objective

To create a more stable and realistic portfolio than traditional methods like Markowitz mean-variance, by combining market information with your own expectations (views).

Market-implied returns
These are the returns the market expects for each asset. We calculate them using a model like CAPM, which assumes investors are rational and markets are in balance.

Investor views
These are your own beliefs or forecasts. Example: ‚ÄúI think mid-cap stocks will do better than large-caps by 2%.‚Äù These views can be based on research, experience, or news.

Confidence in views
How sure you are about your opinions. High confidence means your view influences the portfolio more. Low confidence means the portfolio leans more on market data.

Why use the Black-Litterman model?

Because it gives you a balanced approach:

It respects market data (to avoid overreacting).

It lets you add your own views without making the portfolio unstable.

It prevents extreme or unrealistic asset weights often seen in traditional optimization.

![image.png](data:image/png;base64,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)
"""

-+index_symbol = "^NSEI"
lookback_days = 365 * 2
rf = 0.06
tau = 0.025
views = [
    {"assets": {"TCS": 1, "Infosys": -1}, "view": 0.02, "conf": 0.7},
    {"assets": {"HDFC Bank": 1}, "view": 0.03, "conf": 0.5},
]

def fetch_prices(symbols, start):
    data = yf.download(list(symbols), start=start, progress=False, threads=True)
    if ("Adj Close" in data.columns) or ("Adj Close" == data.columns.name):
        px = data["Adj Close"].copy() if "Adj Close" in data.columns else data.xs("Adj Close", axis=1, level=0)
    else:
        px = data["Close"].copy() if "Close" in data.columns else data.xs("Close", axis=1, level=0)
    if isinstance(px, pd.Series):
        px = px.to_frame()
    return px.dropna(how="all").ffill().dropna()

def last_valid_price(symbol):
    px = yf.download(symbol, period="5d", interval="1d", progress=False)
    col = "Adj Close" if "Adj Close" in px.columns else "Close"
    return float(px[col].iloc[-1])

def market_caps(symbol_map):
    caps = {}
    for name, sym in symbol_map.items():
        info = yf.Ticker(sym).fast_info
        price = info.get("last_price", None)
        if price is None or np.isnan(price):
            price = last_valid_price(sym)
        shares = info.get("shares", None)
        if (shares is None) or (shares == 0) or (shares != shares):
            alt = yf.Ticker(sym).get_info().get("marketCap", None)
            if alt is not None:
                caps[name] = float(alt)
                continue
            caps[name] = np.nan
        else:
            caps[name] = float(shares) * float(price)
    s = pd.Series(caps, dtype="float64")
    if s.isna().any():
        if s.notna().any():
            s = s.fillna(s.median())
        else:
            s = pd.Series({k: 1.0 for k in symbol_map.keys()}, dtype="float64")
    return s

def annualize_stats(rets, periods_per_year=252):
    mu = rets.mean() * periods_per_year
    cov = rets.cov() * periods_per_year
    return mu, cov

def risk_aversion_from_index(index_symbol, rf, start):
    px = fetch_prices([index_symbol], start=start)
    rets = np.log(px / px.shift(1)).dropna()
    mu_ann, cov_ann = annualize_stats(rets)
    var_ann = float(cov_ann.values.squeeze())
    mkt_mu = float(mu_ann.values.squeeze())
    delta = max(1e-6, (mkt_mu - rf) / max(1e-8, var_ann))
    return delta

def build_P_Q_Omega(views, assets, tau, Sigma):
    n = len(assets)
    k = len(views)
    P = np.zeros((k, n))
    Q = np.zeros(k)
    Omega = np.zeros((k, k))
    asset_index = {a: i for i, a in enumerate(assets)}
    for i, v in enumerate(views):
        for a, w in v["assets"].items():
            P[i, asset_index[a]] = float(w)
        Q[i] = float(v["view"])
        conf = max(1e-6, min(0.9999, float(v.get("conf", 0.5))))
        base_var = P[i, :].reshape(1, -1) @ Sigma @ P[i, :].reshape(-1, 1)
        base_var = float(base_var.squeeze())
        Omega[i, i] = ((1 - conf) / conf) * max(1e-10, base_var) * tau
    return P, Q, Omega

def black_litterman(Sigma, w_mkt, delta, tau, P, Q, Omega):
    Pi = delta * Sigma @ w_mkt
    A = np.linalg.inv(tau * Sigma)
    middle = P.T @ np.linalg.inv(Omega) @ P
    rhs = A @ Pi + P.T @ np.linalg.inv(Omega) @ Q
    post_prec = A + middle
    mu_bl = np.linalg.solve(post_prec, rhs)
    Sigma_bl = Sigma + np.linalg.inv(post_prec)
    return mu_bl, Sigma_bl, Pi

def weights_from_meanvar(mu, Sigma, delta):
    w = np.linalg.solve(Sigma + 1e-10*np.eye(Sigma.shape[0]), mu) / max(1e-8, delta)
    w = w / w.sum()
    return w

start_date = (datetime.today() - timedelta(days=lookback_days)).date()
px = fetch_prices(list(tickers.values()), start=start_date)
px.columns = list(tickers.keys())
rets = np.log(px / px.shift(1)).dropna()
mu_ann, Sigma_ann = annualize_stats(rets)
assets = list(mu_ann.index)
caps = market_caps({k: tickers[k] for k in assets})
w_mkt = (caps / caps.sum()).reindex(assets).fillna(1/len(assets)).values
w_mkt = w_mkt / w_mkt.sum()
w_mkt = w_mkt.reshape(-1, 1)
delta = risk_aversion_from_index(index_symbol, rf, start=start_date)
P, Q, Omega = build_P_Q_Omega(views, assets, tau, Sigma_ann.values)
mu_bl, Sigma_bl, Pi = black_litterman(Sigma_ann.values, w_mkt, delta, tau, P, Q, Omega)
w_bl = weights_from_meanvar(mu_bl, Sigma_bl, delta)

out = pd.DataFrame({
    "MktCapWeight": w_mkt.flatten()[:len(assets)],
    "EquilibriumMu(%)": Pi.flatten()[:len(assets)] * 100,
    "PosteriorMu(%)": mu_bl.flatten()[:len(assets)] * 100,
    "BL_Weights": w_bl.flatten()[:len(assets)]
}, index=assets)

print(out)

import yfinance as yf
import pandas as pd
from datetime import datetime, timedelta

# Define time range (last 1 year)
end_date = datetime.today()
start_date = end_date - timedelta(days=365)

# Create empty DataFrame to store results
growth_df = pd.DataFrame(columns=["Company", "Start Price", "End Price", "Growth %"])

# Loop through each ticker
for company, ticker in tickers.items():
    try:
        data = yf.download(ticker, start=start_date, end=end_date)
        if not data.empty:
            start_price = data["Close"].iloc[0]
            end_price = data["Close"].iloc[-1]
            growth = ((end_price - start_price) / start_price) * 100
            growth_df = pd.concat([growth_df, pd.DataFrame({
                "Company": [company],
                "Start Price": [round(start_price, 2)],
                "End Price": [round(end_price, 2)],
                "Growth %": [round(growth, 2)]
            })])
    except Exception as e:
        print(f"Error fetching {company}: {e}")

# Reset index
growth_df.reset_index(drop=True, inplace=True)

# Show results
print(growth_df)

"""## **ESG score calculation**"""

def compute_esg_score(row):
    try:

        e = 1 - (row.get("Debt/Equity", 0) / (row.get("Debt/Equity", 1) + 1))
        s = row.get("Promoter Holding %", 0) / 100 ## csr -
        g = row.get("ROE", 0) / 100
        return round((e + s + g) / 3, 3)
    except:
        return None

data = []
for name, ticker in tickers.items():
    stock = yf.Ticker(ticker)

    try:
        info = stock.info

        market_cap = info.get("marketCap", None)
        roe = info.get("returnOnEquity", 0) * 100 if info.get("returnOnEquity") else 0
        de_ratio = info.get("debtToEquity", 0)
        promoter_holding = info.get("heldPercentInsiders", 0) * 100
        data.append({
            "Stock": name,
            "Market Cap": market_cap,
            "Debt/Equity": de_ratio,
            "Promoter Holding %": promoter_holding,
            "ROE": roe
        })
    except Exception as e:
        print(f"Error fetching {name}: {e}")

df = pd.DataFrame(data)
df["ESG Score"] = df.apply(compute_esg_score, axis=1)
df["Weight"] = df["Market Cap"] / df["Market Cap"].sum()

print(df)

import matplotlib.pyplot as plt

plt.figure(figsize=(10,6))
plt.bar(df["Stock"], df["ESG Score"], color="skyblue")
plt.xticks(rotation=45, ha="right")
plt.title("ESG Score per Stock")
plt.xlabel("Stocks")
plt.ylabel("ESG Score")
plt.show()

sorted_df = df.sort_values("ESG Score")

plt.figure(figsize=(10,6))
plt.plot(sorted_df["Stock"], sorted_df["ESG Score"], marker="o", linestyle="-")
plt.xticks(rotation=45, ha="right")
plt.title("ESG Scores Trend Across Stocks")
plt.ylabel("ESG Score")
plt.show()

import numpy as np

sector_scores = df.groupby("Stock")["ESG Score"].mean()
categories = list(sector_scores.index)
values = list(sector_scores.values)

N = len(categories)
angles = np.linspace(0, 2*np.pi, N, endpoint=False).tolist()
values += values[:1]
angles += angles[:1]

plt.figure(figsize=(8,8))
ax = plt.subplot(111, polar=True)
ax.plot(angles, values, "o-", linewidth=2)
ax.fill(angles, values, alpha=0.25)
ax.set_xticks(angles[:-1])
ax.set_xticklabels(categories)
plt.title("Radar Chart of Average ESG by Sector")
plt.show()

import numpy as np
import pandas as pd

CFG = {
    "columns": {
        "name": "Name",
        "symbol": "Symbol",
        "sector": "Sector",
        "esg": "ESG Score",
        "pe": "P/E",
        "roce": "ROCE %",
        "de": "Debt/Equity",
        "divy": "Div Yld %",
        "mc": "Market Cap Rs.Cr.",
        "prom": "Promoter Holding %",
        "qtr_profit_var": "Qtr Profit Var %"
    },
    "filters": {
        "max_de": 1.5,
        "min_roce": 12.0,
        "min_prom": 40.0,
        "pe_min": 5.0,
        "pe_max": 80.0
    },
    "weights": {
        "esg_pctile": 0.60,
        "quality": 0.40
    },
    "rules": {
        "buy_esg_pctile": 0.70,
        "buy_composite": 0.65,
        "watch_esg_pctile": 0.45,
        "watch_composite": 0.50
    },
    "topn": 15
}

def _col(df, key):
    return CFG["columns"][key]

def prepare(df):
    needed = [_col(df, k) for k in ["name","symbol","sector","esg","pe","roce","de","divy","mc"]]
    optional = []
    for k in ["prom","qtr_profit_var"]:
        if CFG["columns"][k] in df.columns:
            optional.append(CFG["columns"][k])
    use_cols = [c for c in needed + optional if c in df.columns]
    out = df[use_cols].copy()
    num_cols = [c for c in use_cols if c not in [_col(df,"name"), _col(df,"symbol"), _col(df,"sector")]]
    for c in num_cols:
        out[c] = pd.to_numeric(out[c], errors="coerce")
    out = out.dropna(subset=[_col(df,"esg")]).reset_index(drop=True)
    return out

def add_sector_esg_percentile(d):
    esg_col = _col(d,"esg")
    sector_col = _col(d,"sector")
    d["ESG_pctile_sector"] = d.groupby(sector_col)[esg_col].rank(pct=True)
    return d

def minmax_ser(s):
    s = s.astype(float)
    if s.max() == s.min():
        return pd.Series(0.5, index=s.index)
    return (s - s.min()) / (s.max() - s.min())

def add_quality_pillar(d):
    roce = minmax_ser(d[_col(d,"roce")].fillna(d[_col(d,"roce")].median()))
    de = d[_col(d,"de")].replace([np.inf, -np.inf], np.nan)
    de = minmax_ser(1 / (1 + de.fillna(de.median())))
    parts = [roce, de]
    if _col(d,"qtr_profit_var") in d.columns:
        growth = minmax_ser(d[_col(d,"qtr_profit_var")].fillna(d[_col(d,"qtr_profit_var")].median()))
        parts.append(growth)
    d["Quality_pillar"] = pd.concat(parts, axis=1).mean(axis=1)
    return d

def add_filters(d):
    f = CFG["filters"]
    d["PASS_DE"]   = d[_col(d,"de")]   <= f["max_de"]
    d["PASS_ROCE"] = d[_col(d,"roce")] >= f["min_roce"]
    d["PASS_PE"]   = (d[_col(d,"pe")] >= f["pe_min"]) & (d[_col(d,"pe")] <= f["pe_max"])
    if _col(d,"prom") in d.columns:
        d["PASS_PROM"] = d[_col(d,"prom")] >= f["min_prom"]
    else:
        d["PASS_PROM"] = True
    d["PASS_ALL"] = d[["PASS_DE","PASS_ROCE","PASS_PE","PASS_PROM"]].all(axis=1)
    return d

def add_composite_and_decision(d):
    w = CFG["weights"]
    r = CFG["rules"]
    d["Composite"] = (w["esg_pctile"] * d["ESG_pctile_sector"] +
                      w["quality"]    * d["Quality_pillar"])
    conditions = [
        (d["PASS_ALL"] & (d["ESG_pctile_sector"] >= r["buy_esg_pctile"]) & (d["Composite"] >= r["buy_composite"])),
        (d["PASS_ALL"] & (d["ESG_pctile_sector"] >= r["watch_esg_pctile"]) & (d["Composite"] >= r["watch_composite"]))
    ]
    choices = ["BUY", "WATCH"]
    d["Decision"] = np.select(conditions, choices, default="AVOID")
    return d

def add_reasons(d):
    def fmt(x, nd=2):
        try:
            return f"{float(x):,.{nd}f}"
        except:
            return "-"
    cols = CFG["columns"]
    rows = []
    for _, row in d.iterrows():
        reason = []
        reason.append(f"ESG_pctile(sector)={fmt(row['ESG_pctile_sector'],2)}")
        reason.append(f"Composite={fmt(row['Composite'],2)}")
        reason.append(f"ROCE%={fmt(row[cols['roce']],1)}")
        reason.append(f"D/E={fmt(row[cols['de']],2)}")
        reason.append(f"P/E={fmt(row[cols['pe']],1)}")
        if cols["prom"] in d.columns:
            reason.append(f"Prom%={fmt(row[cols['prom']],1)}")
        if cols["qtr_profit_var"] in d.columns:
            reason.append(f"QtrProfitVar%={fmt(row[cols['qtr_profit_var']],1)}")
        rows.append(" | ".join(reason))
    d["Reasons"] = rows
    return d

def make_esg_recommendations(df_live):
    d = prepare(df_live)
    d = add_sector_esg_percentile(d)
    d = add_quality_pillar(d)
    d = add_filters(d)
    d = add_composite_and_decision(d)
    d = add_reasons(d)
    dec_rank = {"BUY": 0, "WATCH": 1, "AVOID": 2}
    d["__rank__"] = d["Decision"].map(dec_rank)
    d_sorted = d.sort_values(["__rank__", "Composite"], ascending=[True, False]).drop(columns="__rank__")
    view_cols = [
        _col(d,"name"), _col(d,"symbol"), _col(d,"sector"),
        _col(d,"esg"), "ESG_pctile_sector", "Quality_pillar", "Composite", "Decision",
        _col(d,"roce"), _col(d,"de"), _col(d,"pe"), _col(d,"divy"), _col(d,"mc")
    ]
    view_cols = [c for c in view_cols if c in d_sorted.columns]
    topn = CFG["topn"]
    return d_sorted, d_sorted[view_cols].head(topn)

import pandas as pd
top5_esg = df.sort_values(by="ESG Score", ascending=False).head(5)

print("Top 5 Stocks Based on ESG Score:")
print(top5_esg[["Stock", "ESG Score"]])

import matplotlib.pyplot as plt

plt.figure(figsize=(8,6))
plt.bar(top5_esg["Stock"], top5_esg["ESG Score"], color="seagreen")
plt.title("Top 5 Stocks by ESG Score", fontsize=14)
plt.xlabel("Stock Name")
plt.ylabel("ESG Score")
plt.xticks(rotation=45)
plt.show()

import pandas as pd

def decision_model(score):
    """
    Simple ESG-based decision rule:
    - BUY  if ESG Score >= 0.70
    - HOLD if 0.50 <= ESG Score < 0.70
    - SELL if ESG Score < 0.50
    """
    if score >= 0.70:
        return "BUY"
    elif score >= 0.50:
        return "HOLD"
    else:
        return "SELL"

# Apply decision model to df
df["Decision"] = df["ESG Score"].apply(decision_model)

# Show results sorted by ESG Score
result = df.sort_values(by="ESG Score", ascending=False)[["Stock", "ESG Score", "Decision"]]
print(result.head(15))

# ESG Decision Model thresholds
def decision_model(esg_score):
    if esg_score >= 0.7:
        return "BUY"
    elif 0.4 <= esg_score < 0.7:
        return "HOLD"
    else:
        return "SELL"

# Run infinite loop for live updates
while True:
    stock_data = []

    for stock, ticker in tickers.items():
        try:
            data = yf.Ticker(ticker)
            live_price = data.history(period="1d")["Close"].iloc[-1]

            # For demo, simulate ESG Score randomly (replace with actual ESG data source)
            import random
            esg_score = round(random.uniform(0.2, 0.9), 2)

            stock_data.append({
                "Stock": stock,
                "Ticker": ticker,
                "Live Price": round(live_price, 2),
                "ESG Score": esg_score,
                "Decision": decision_model(esg_score)
            })
        except Exception as e:
            print(f"Error fetching {stock}: {e}")

    # Convert to DataFrame
    df = pd.DataFrame(stock_data)

    # Sort by ESG Score
    df_sorted = df.sort_values(by="ESG Score", ascending=False)

    # Print live analysis
    print("\n=== Live ESG-Based Stock Decisions ===")
    print(df_sorted.to_string(index=False))

    # Wait for 1 minute before next fetch
    time.sleep(60)

import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
import time

# List of stock symbols
tickers = {
    "TCS": "TCS.NS",
    "Infosys": "INFY.NS",
    "HDFC Bank": "HDFCBANK.NS",
    "ICICI Bank": "ICICIBANK.NS",
    "Kotak Mah. Bank": "KOTAKBANK.NS",
    "Hind. Unilever": "HINDUNILVR.NS",
    "ITC": "ITC.NS",
    "Nestle India": "NESTLEIND.NS",
    "Asian Paints": "ASIANPAINT.NS",
    "Tata Steel": "TATASTEEL.NS",
    "Tata Motors": "TATAMOTORS.NS",
    "Maruti Suzuki": "MARUTI.NS",
    "Reliance Industr": "RELIANCE.NS",
    "Adani Green": "ADANIGREEN.NS",
    "Power Grid Corpn": "POWERGRID.NS",
    "L&T Finance Ltd": "LTF.NS",
    "Larsen & Toubro": "LT.NS",
    "DLF": "DLF.NS",
    "Lodha Developers": "LODHA.NS",
    "Godrej Propert.": "GODREJPROP.NS",
    "Hindustan Zinc Ltd": "HINDZINC.NS",
    "Solar Industries India Ltd": "SOLARINDS.NS",
    "Mazagon Dock Shipbuilders Ltd": "MAZDOCK.NS",
    "Max Healthcare Institute Ltd": "MAXHEALTH.NS",
    "HDFC AMC": "HDFCAMC.NS",
    "Union Bank": "UNIONBANK.NS",
    "Mankind Pharma": "MANKIND.NS",
    "Indus Towers": "INDUSTOWER.NS",
    "Muthoot Finance": "MUTHOOTFIN.NS",
    "Polycab India": "POLYCAB.NS",
    "Indian Energy Exchange": "IEX.NS",
    "CDSL": "CDSL.NS",
    "Aptus Housing": "APTUS.NS",
    "Five-Star Business Finance": "FIVESTAR.NS",
    "Clean Science": "CLEAN.NS"
}

# Dummy ESG scores (replace with your live ESG data if available)
import random
esg_scores = {stock: round(random.uniform(0, 1), 2) for stock in tickers.keys()}

def get_recommendation(score):
    if score >= 0.7:
        return "BUY"
    elif score >= 0.4:
        return "HOLD"
    else:
        return "SELL"

# Run live every 1 min
while True:
    data = []

    for stock, symbol in tickers.items():
        try:
            live_price = yf.Ticker(symbol).history(period="1d", interval="1m")["Close"].iloc[-1]
            score = esg_scores.get(stock, 0.5)
            decision = get_recommendation(score)
            data.append([stock, round(live_price, 2), score, decision])
        except:
            data.append([stock, None, None, "No Data"])

    df = pd.DataFrame(data, columns=["Stock", "Price (INR)", "ESG Score", "Recommendation"])
    print(df)

    # Visualization
    plt.figure(figsize=(14, 8))

    # Subplot 1: ESG Score Bar Chart
    plt.subplot(1, 2, 1)
    colors = df["Recommendation"].map({"BUY": "green", "HOLD": "orange", "SELL": "red"})
    plt.bar(df["Stock"], df["ESG Score"], color=colors)
    plt.xticks(rotation=90)
    plt.title("ESG Score by Stock (Trading Signal)")
    plt.ylabel("ESG Score (0-1)")

    # Subplot 2: Pie Chart of Recommendations
    plt.subplot(1, 2, 2)
    df["Recommendation"].value_counts().plot.pie(autopct="%1.1f%%", colors=["green", "orange", "red"])
    plt.title("Portfolio Recommendation Distribution")

    plt.tight_layout()
    plt.show()

    # Sleep for 1 min before refreshing
    time.sleep(60)

""" ## ENTROPY

"""

import numpy as np

def portfolio_entropy(weights):
    """
    Calculate Shannon entropy of portfolio weights.
    Entropy = - Œ£ (w_i * log(w_i))

    Args:
        weights (array-like): Portfolio weights (must sum to 1)

    Returns:
        float: Entropy value
    """
    weights = np.array(weights)
    weights = weights[weights > 0]  # ignore zeros to avoid log(0)
    return -np.sum(weights * np.log(weights))

# Example: portfolio with 4 assets
weights = [0.4, 0.3, 0.2, 0.1]  # 40%, 30%, 20%, 10%
entropy_value = portfolio_entropy(weights)

print("Portfolio Weights:", weights)
print("Entropy (diversification measure):", entropy_value)

import yfinance as yf
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# --- Stock List (demo subset, extendable) ---

# List of stock symbols
tickers = {
    ## large cap stocks
    "TCS": "TCS.NS",
    "Infosys": "INFY.NS",
    "HDFC Bank": "HDFCBANK.NS",
    "ICICI Bank": "ICICIBANK.NS",
    "Kotak Mah. Bank": "KOTAKBANK.NS",
    "Hind. Unilever": "HINDUNILVR.NS",
    "ITC": "ITC.NS",
    "Nestle India": "NESTLEIND.NS",
    "Asian Paints": "ASIANPAINT.NS",
    "Tata Steel": "TATASTEEL.NS",
    "Tata Motors": "TATAMOTORS.NS",
    "Maruti Suzuki": "MARUTI.NS",
    "Reliance Industr": "RELIANCE.NS",
    "Adani Green": "ADANIGREEN.NS",
    "Power Grid Corpn": "POWERGRID.NS",
    "L&T Finance Ltd": "LTF.NS",
    "Larsen & Toubro": "LT.NS",
    "DLF": "DLF.NS",
    "Lodha Developers": "LODHA.NS",
    "Godrej Propert.": "GODREJPROP.NS",

    # mid cap stocks
    "Hindustan Zinc Ltd": "HINDZINC.NS",
    "Solar Industries India Ltd": "SOLARINDS.NS",
    "Mazagon Dock Shipbuilders Ltd": "MAZDOCK.NS",
    "Max Healthcare Institute Ltd": "MAXHEALTH.NS",
    "HDFC Asset Management Company Ltd": "HDFCAMC.NS",
    "Union Bank of India Ltd": "UNIONBANK.NS",
    "Mankind Pharma Ltd": "MANKIND.NS",
    "Indus Towers Ltd": "INDUSTOWER.NS",
    "Muthoot Finance Ltd": "MUTHOOTFIN.NS",
    "Polycab India Ltd": "POLYCAB.NS",

    # Small-cap stocks
    "Indian Energy Exchange Ltd": "IEX.NS",
    "Central Depository Services (India) Ltd": "CDSL.NS",
    "Aptus Value Housing Finance India Ltd": "APTUS.NS",
    "Five-Star Business Finance Ltd": "FIVESTAR.NS",
    "Clean Science and Technology Ltd": "CLEAN.NS"
}

# --- Download Live Data (using Close instead of Adj Close) ---
data = yf.download(list(tickers.values()), period="6mo")["Close"]

# --- Calculate Daily Returns ---
returns = data.pct_change().dropna()

# --- Compute Weights (Inverse Volatility method) ---
volatility = returns.std()
inv_vol = 1 / volatility
weights = inv_vol / inv_vol.sum()

# --- Entropy Functions ---
def portfolio_entropy(weights):
    """Shannon entropy of portfolio weights."""
    weights = np.array(weights)
    weights = weights[weights > 0]
    return -np.sum(weights * np.log(weights))

def stock_entropy_contribution(weights, tickers):
    """Contribution of each stock to entropy."""
    contributions = {}
    for t, w in zip(tickers.keys(), weights):
        contributions[t] = -w * np.log(w) if w > 0 else 0
    return contributions

def buy_sell_signal(weights, tickers, threshold=0.05):
    """Buy/Hold/Sell based on entropy contribution."""
    contrib = stock_entropy_contribution(weights, tickers)
    signals = {}
    for stock, value in contrib.items():
        if value > threshold:
            signals[stock] = "BUY ‚úÖ"
        elif value < threshold / 2:
            signals[stock] = "SELL ‚ùå"
        else:
            signals[stock] = "HOLD ‚öñÔ∏è"
    return signals

# --- Calculate Entropy & Signals ---
entropy_value = portfolio_entropy(weights)
signals = buy_sell_signal(weights, tickers)

# --- Display Results ---
print("\nüìä Portfolio Entropy:", entropy_value, "\n")
df_signals = pd.DataFrame({
    "Stock": list(signals.keys()),
    "Weight": weights.values,
    "Signal": list(signals.values())
})
print(df_signals)

# --- Visualization ---
contrib = stock_entropy_contribution(weights, tickers)
plt.figure(figsize=(12,6))
bars = plt.bar(contrib.keys(), contrib.values(), edgecolor="black")
plt.xticks(rotation=45)
plt.ylabel("Entropy Contribution")
plt.title("Entropy-Based Buy/Hold/Sell Signals (using Close Prices)")

# Color bars by signals
for bar, stock in zip(bars, contrib.keys()):
    if signals[stock].startswith("BUY"):
        bar.set_color("green")
    elif signals[stock].startswith("SELL"):
        bar.set_color("red")
    else:
        bar.set_color("orange")

plt.tight_layout()
plt.show()

"""## **GAME THEORY**

##**üéØ Game Theory in Portfolio Optimization**

**Players**: Investors (risk-averse vs. risk-seeking) or asset classes (large-cap vs. mid-cap vs. small-cap).

**Strategies**: Portfolio allocation choices (weights assigned to stocks).

**Payoffs**: Expected returns adjusted for risk (Sharpe ratio, utility, etc.).

We can model this as a non-cooperative game where each ‚Äúplayer‚Äù (stock group or investor type) chooses allocations to maximize their utility.
The solution will be the Nash Equilibrium of allocations.

üìä Interpretation

**Payoff Matrix** ‚Üí Shows Sharpe ratios for both players under different strategy mixes.

**Nash Equilibria** ‚Üí Stable allocation strategies where no player benefits by deviating.

You can extend this to:

3+ players (Large, Mid, Small caps).

Mixed strategies (probabilistic allocation).

Incorporate ESG scores / entropy as penalties in payoff.
"""

import yfinance as yf
import numpy as np
import pandas as pd
import nashpy as nash
import itertools

# ---- Stock Universe ----
tickers = {
    "TCS": "TCS.NS", "Infosys": "INFY.NS", "HDFC Bank": "HDFCBANK.NS",
    "ICICI Bank": "ICICIBANK.NS", "Kotak Mah. Bank": "KOTAKBANK.NS",
    "Hind. Unilever": "HINDUNILVR.NS", "ITC": "ITC.NS", "Nestle India": "NESTLEIND.NS",
    "Asian Paints": "ASIANPAINT.NS", "Tata Steel": "TATASTEEL.NS", "Tata Motors": "TATAMOTORS.NS",
    "Maruti Suzuki": "MARUTI.NS", "Reliance Industr": "RELIANCE.NS", "Adani Green": "ADANIGREEN.NS",
    "Power Grid Corpn": "POWERGRID.NS", "L&T Finance Ltd": "LTF.NS", "Larsen & Toubro": "LT.NS",
    "DLF": "DLF.NS", "Lodha Developers": "LODHA.NS", "Godrej Propert.": "GODREJPROP.NS",
    "Hindustan Zinc Ltd": "HINDZINC.NS", "Solar Industries India Ltd": "SOLARINDS.NS",
    "Mazagon Dock Shipbuilders Ltd": "MAZDOCK.NS", "Max Healthcare Institute Ltd": "MAXHEALTH.NS",
    "HDFC AMC": "HDFCAMC.NS", "Union Bank": "UNIONBANK.NS", "Mankind Pharma": "MANKIND.NS",
    "Indus Towers": "INDUSTOWER.NS", "Muthoot Finance": "MUTHOOTFIN.NS", "Polycab India": "POLYCAB.NS",
    "IEX": "IEX.NS", "CDSL": "CDSL.NS", "Aptus Housing": "APTUS.NS", "Five-Star Finance": "FIVESTAR.NS",
    "Clean Science": "CLEAN.NS"
}

# ---- Download Price Data ----
data = yf.download(
    list(tickers.values()),
    start="2022-01-01",
    end="2025-01-01",
    auto_adjust=True
)['Close']

returns = data.pct_change().dropna()

# ---- Expected Returns & Covariance ----
mean_returns = returns.mean() * 252
cov_matrix = returns.cov() * 252

# ---- Define groups ----
large_mid_caps = ["TCS.NS","INFY.NS","HDFCBANK.NS","ICICIBANK.NS","KOTAKBANK.NS","HINDUNILVR.NS","ITC.NS"]
small_caps = ["IEX.NS","CDSL.NS","APTUS.NS","FIVESTAR.NS","CLEAN.NS"]

# ---- Payoff Function (Sharpe Ratio approx) ----
def payoff(portfolio):
    w = np.array([1/len(portfolio)]*len(portfolio))  # equal weights
    ret = np.dot(w, mean_returns[portfolio])
    vol = np.sqrt(np.dot(w.T, np.dot(cov_matrix.loc[portfolio, portfolio], w)))
    return ret/vol  # Sharpe ratio

# Player strategies
player1_strategies = [large_mid_caps, large_mid_caps[:4], large_mid_caps[-3:]]
player2_strategies = [small_caps, small_caps[:2], small_caps[-2:]]

# Build payoff matrices
A = np.zeros((len(player1_strategies), len(player2_strategies)))  # Player 1
B = np.zeros((len(player1_strategies), len(player2_strategies)))  # Player 2

for i, s1 in enumerate(player1_strategies):
    for j, s2 in enumerate(player2_strategies):
        A[i, j] = payoff(s1)   # Player 1 payoff
        B[i, j] = payoff(s2)   # Player 2 payoff

# ---- Nash Equilibrium ----
game = nash.Game(A, B)
equilibria = list(game.support_enumeration())

print("Payoff Matrix for Player 1:\n", A)
print("Payoff Matrix for Player 2:\n", B)
print("\nNash Equilibria:\n", equilibria)

import yfinance as yf
import numpy as np
import pandas as pd
import nashpy as nash
import itertools

# ---- Stock Universe ----
tickers = {
    "TCS": "TCS.NS", "Infosys": "INFY.NS", "HDFC Bank": "HDFCBANK.NS",
    "ICICI Bank": "ICICIBANK.NS", "Kotak Mah. Bank": "KOTAKBANK.NS",
    "Hind. Unilever": "HINDUNILVR.NS", "ITC": "ITC.NS", "Nestle India": "NESTLEIND.NS",
    "Asian Paints": "ASIANPAINT.NS", "Tata Steel": "TATASTEEL.NS", "Tata Motors": "TATAMOTORS.NS",
    "Maruti Suzuki": "MARUTI.NS", "Reliance Industr": "RELIANCE.NS", "Adani Green": "ADANIGREEN.NS",
    "Power Grid Corpn": "POWERGRID.NS", "L&T Finance Ltd": "LTF.NS", "Larsen & Toubro": "LT.NS",
    "DLF": "DLF.NS", "Lodha Developers": "LODHA.NS", "Godrej Propert.": "GODREJPROP.NS",
    "Hindustan Zinc Ltd": "HINDZINC.NS", "Solar Industries India Ltd": "SOLARINDS.NS",
    "Mazagon Dock Shipbuilders Ltd": "MAZDOCK.NS", "Max Healthcare Institute Ltd": "MAXHEALTH.NS",
    "HDFC AMC": "HDFCAMC.NS", "Union Bank": "UNIONBANK.NS", "Mankind Pharma": "MANKIND.NS",
    "Indus Towers": "INDUSTOWER.NS", "Muthoot Finance": "MUTHOOTFIN.NS", "Polycab India": "POLYCAB.NS",
    "IEX": "IEX.NS", "CDSL": "CDSL.NS", "Aptus Housing": "APTUS.NS", "Five-Star Finance": "FIVESTAR.NS",
    "Clean Science": "CLEAN.NS"
}

# ---- Download Price Data ----
data = yf.download(list(tickers.values()), start="2022-01-01", end="2025-01-01")
if "Adj Close" in data.columns:
    prices = data["Adj Close"].dropna()
elif "Close" in data.columns:
    prices = data["Close"].dropna()
else:
    raise ValueError("Neither 'Adj Close' nor 'Close' found in data.")

returns = prices.pct_change().dropna()

# ---- Expected Returns & Covariance ----
mean_returns = returns.mean() * 252
cov_matrix = returns.cov() * 252

# ---- Define groups ----
large_mid_caps = ["TCS.NS","INFY.NS","HDFCBANK.NS","ICICIBANK.NS","KOTAKBANK.NS","HINDUNILVR.NS","ITC.NS"]
small_caps = ["IEX.NS","CDSL.NS","APTUS.NS","FIVESTAR.NS","CLEAN.NS"]

# ---- Payoff Function (Sharpe Ratio approx) ----
def payoff(portfolio):
    # Ensure portfolio list contains valid tickers that exist in mean_returns and cov_matrix indices
    valid_portfolio = [t for t in portfolio if t in mean_returns.index and t in cov_matrix.index]
    if not valid_portfolio:
        return 0 # Or handle appropriately

    w = np.array([1/len(valid_portfolio)]*len(valid_portfolio))  # equal weights
    ret = np.dot(w, mean_returns[valid_portfolio])
    # Ensure sub-matrix is created with valid tickers
    sub_cov_matrix = cov_matrix.loc[valid_portfolio, valid_portfolio]
    vol = np.sqrt(np.dot(w.T, np.dot(sub_cov_matrix, w)))
    return ret/vol  # Sharpe ratio


# Player strategies
player1_strategies = [large_mid_caps, large_mid_caps[:4], large_mid_caps[-3:]]
player2_strategies = [small_caps, small_caps[:2], small_caps[-2:]]

# Build payoff matrices
A = np.zeros((len(player1_strategies), len(player2_strategies)))  # Player 1
B = np.zeros((len(player1_strategies), len(player2_strategies)))  # Player 2

for i, s1 in enumerate(player1_strategies):
    for j, s2 in enumerate(player2_strategies):
        A[i, j] = payoff(s1)   # Player 1 payoff
        B[i, j] = payoff(s2)   # Player 2 payoff

# ---- Nash Equilibrium ----
game = nash.Game(A, B)
equilibria = list(game.support_enumeration())

print("Payoff Matrix for Player 1:\n", A)
print("Payoff Matrix for Player 2:\n", B)
print("\nNash Equilibria:\n", equilibria)

"""The portfolio is not just a collection of stocks‚Äîit‚Äôs a strategic battleground where each asset is a player in a game, competing and cooperating to secure its place in the portfolio. Instead of blindly chasing returns, the code applies game theory to understand how these ‚Äúplayers‚Äù interact, building a payoff matrix that captures both risk and reward. By finding the Nash equilibrium, the model uncovers a state of balance‚Äîwhere no stock can gain an advantage by shifting its strategy alone. This transforms portfolio optimization into a chess-like game of finance, where the final allocation is not only mathematically optimal but also strategically resilient. It‚Äôs a fresh and creative twist on investing, blending the precision of mathematics with the psychology of strategic decision-making."""

# Download stock price data
data = yf.download(
    list(tickers.values()),
    start="2022-01-01",
    end="2025-01-01",
    auto_adjust=True  # ensures clean 'Close' prices
)['Close']

# Calculate log returns
returns = np.log(data / data.shift(1)).dropna()

# Mean returns & covariance
mean_returns = returns.mean() * 252
cov_matrix = returns.cov() * 252

# Construct payoff matrix (expected returns vs risk penalty)
# Payoff ~ Expected Return - Œª * Variance
lam = 0.5
payoff_matrix = pd.DataFrame(
    np.outer(mean_returns, np.ones(len(mean_returns))) -
    lam * np.outer(np.ones(len(mean_returns)), np.diag(cov_matrix)),
    index=mean_returns.index,
    columns=mean_returns.index
)

print("\nPayoff Matrix (Game Theory Setup):")
print(payoff_matrix.round(4))

# Create a 2-player zero-sum game (Investor vs Market)
A = payoff_matrix.values
game = nash.Game(A, -A)

# Find Nash Equilibrium (mixed strategy)
equilibria = list(game.support_enumeration())
print("\nNash Equilibria (Mixed Strategies):")
for eq in equilibria:
    print(eq)

# Convert equilibrium strategy into portfolio weights
if equilibria:
    investor_strategy = equilibria[0][0]
    portfolio_weights = pd.Series(investor_strategy, index=mean_returns.index)
    print("\nOptimal Portfolio Weights (Game Theory):")
    print(portfolio_weights.round(4))

    # Visualization
    plt.figure(figsize=(8, 6))
    portfolio_weights.plot(kind="bar", color="teal", alpha=0.7)
    plt.title("Game Theory Optimal Portfolio Allocation (Nash Equilibrium)")
    plt.ylabel("Weight")
    plt.xlabel("Stocks")
    plt.xticks(rotation=45)
    plt.show()

import yfinance as yf
import pandas as pd
import numpy as np
import random
import time
from scipy.optimize import minimize

tickers = {
    "TCS": "TCS.NS", "Infosys": "INFY.NS", "HDFC Bank": "HDFCBANK.NS",
    "ICICI Bank": "ICICIBANK.NS", "Kotak Mah. Bank": "KOTAKBANK.NS",
    "Hind. Unilever": "HINDUNILVR.NS", "ITC": "ITC.NS", "Nestle India": "NESTLEIND.NS",
    "Asian Paints": "ASIANPAINT.NS", "Tata Steel": "TATASTEEL.NS", "Tata Motors": "TATAMOTORS.NS",
    "Maruti Suzuki": "MARUTI.NS", "Reliance Industr": "RELIANCE.NS", "Adani Green": "ADANIGREEN.NS",
    "Power Grid Corpn": "POWERGRID.NS", "L&T Finance Ltd": "LTF.NS", "Larsen & Toubro": "LT.NS",
    "DLF": "DLF.NS", "Lodha Developers": "LODHA.NS", "Godrej Propert.": "GODREJPROP.NS",
    "Hindustan Zinc Ltd": "HINDZINC.NS", "Solar Industries India Ltd": "SOLARINDS.NS",
    "Mazagon Dock": "MAZDOCK.NS", "Max Healthcare": "MAXHEALTH.NS", "HDFC AMC": "HDFCAMC.NS",
    "Union Bank": "UNIONBANK.NS", "Mankind Pharma": "MANKIND.NS", "Indus Towers": "INDUSTOWER.NS",
    "Muthoot Finance": "MUTHOOTFIN.NS", "Polycab India": "POLYCAB.NS",
    "IEX": "IEX.NS", "CDSL": "CDSL.NS", "Aptus Housing": "APTUS.NS",
    "Five-Star Fin": "FIVESTAR.NS", "Clean Science": "CLEAN.NS"
}

def esg_decision(score):
    if score >= 0.7:
        return "BUY"
    elif score >= 0.4:
        return "HOLD"
    else:
        return "SELL"


def black_litterman(cov, pi, P, Q, tau=0.05, omega=None):
    """
    cov: covariance matrix of returns
    pi: equilibrium excess returns (CAPM prior)
    P: link matrix for investor views
    Q: expected returns for views
    """
    if omega is None:
        omega = np.diag(np.diag(P @ cov @ P.T)) * tau

    M = np.linalg.inv(np.linalg.inv(tau * cov) + P.T @ np.linalg.inv(omega) @ P)
    adj_return = M @ (np.linalg.inv(tau * cov) @ pi + P.T @ np.linalg.inv(omega) @ Q)
    return adj_return


def entropy_obj(w, mu, cov, lam=0.1):
    w = np.array(w)
    ret = w @ mu
    risk = w @ cov @ w
    entropy = -np.sum(w * np.log(w + 1e-9))  # Shannon entropy
    return -(ret - lam * risk + 0.01 * entropy)


def nash_bargaining(mu, cov, esg_scores):
    n = len(mu)
    init_w = np.ones(n) / n

    cons = ({'type': 'eq', 'fun': lambda w: np.sum(w) - 1})
    bounds = [(0, 1)] * n

    def utility(w):
        ret = w @ mu
        risk = w @ cov @ w
        esg = np.sum(w * esg_scores)

        return -(np.log(ret + 1e-9) + np.log(esg + 1e-9) - np.log(risk + 1e-9))

    res = minimize(utility, init_w, constraints=cons, bounds=bounds)
    return res.x if res.success else init_w


def run_portfolio():

    data = yf.download(list(tickers.values()), period="1y")["Close"].dropna()
    log_ret = np.log(data / data.shift(1)).dropna()
    mu = log_ret.mean().values * 252
    cov = log_ret.cov().values * 252


    esg_scores = np.array([round(random.uniform(0, 1), 2) for _ in range(len(tickers))])

    pi = mu
    P = np.array([[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1] + [0] * (len(tickers) - 13)])
    Q = np.array([0.15])  # expected excess return
    bl_mu = black_litterman(cov, pi, P, Q)


    n = len(mu)
    init_w = np.ones(n) / n
    cons = ({'type': 'eq', 'fun': lambda w: np.sum(w) - 1})
    bounds = [(0, 1)] * n
    res = minimize(entropy_obj, init_w, args=(bl_mu, cov), constraints=cons, bounds=bounds)
    entropy_weights = res.x if res.success else init_w


    gt_weights = nash_bargaining(bl_mu, cov, esg_scores)


    final_weights = 0.5 * entropy_weights + 0.5 * gt_weights

    df = pd.DataFrame({
        "Stock": list(tickers.keys()),
        "Symbol": list(tickers.values()),
        "ESG Score": esg_scores,
        "BL Expected Return": bl_mu,
        "Entropy Wt": entropy_weights,
        "Game Theory Wt": gt_weights,
        "Final Wt": final_weights
    })

    return df.sort_values(by="Final Wt", ascending=False)


if __name__ == "__main__":
    portfolio = run_portfolio()
    print("\n=== Optimized Portfolio ===")
    print(portfolio.head(35))

def normalize(value, min_val, max_val):
    if pd.isna(value):
        return np.nan
    return max(0, min(1, (value - min_val) / (max_val - min_val)))

import numpy as np
import pandas as pd

# Normalization helper
def normalize(value, min_val, max_val):
    if pd.isna(value):
        return np.nan
    return max(0, min(1, (value - min_val) / (max_val - min_val)))


def compute_esg_advanced(metrics):
    """
    Calculate an advanced ESG Score using environmental, social, and governance metrics.
    metrics: dict containing all values.
    Returns ESG score (0-100)
    """

    # --- ENVIRONMENTAL ---
    E_scores = []
    E_scores.append(1 - normalize(metrics.get("GHG Emissions", np.nan), 0, 1000))   # lower is better
    E_scores.append(1 - normalize(metrics.get("Energy Consumption", np.nan), 0, 100))  # lower = better
    E_scores.append(1 - normalize(metrics.get("Water Usage", np.nan), 0, 100))  # lower = better
    E_scores.append(normalize(metrics.get("Waste Recycling Rate", np.nan), 0, 100))  # higher = better
    E_scores.append(1 - normalize(metrics.get("Land Impact", np.nan), 0, 10))  # lower = better
    E_scores.append(normalize(metrics.get("Environmental Policies", np.nan), 0, 1))  # 0=no, 1=yes

    E = np.nanmean(E_scores) * 100


    # --- SOCIAL ---
    S_scores = []
    S_scores.append(normalize(metrics.get("Diversity Rate", np.nan), 0, 100))
    S_scores.append(normalize(metrics.get("Labor Compliance", np.nan), 0, 1))
    S_scores.append(1 - normalize(metrics.get("Injury Rate", np.nan), 0, 10))
    S_scores.append(normalize(metrics.get("Employee Training Hours", np.nan), 0, 100))
    S_scores.append(normalize(metrics.get("Community Programs", np.nan), 0, 1))
    S_scores.append(normalize(metrics.get("Data Privacy Score", np.nan), 0, 1))

    S = np.nanmean(S_scores) * 100


    # --- GOVERNANCE ---
    G_scores = []
    G_scores.append(normalize(metrics.get("Board Independence", np.nan), 0, 1))
    G_scores.append(normalize(metrics.get("Board Diversity", np.nan), 0, 1))
    G_scores.append(normalize(metrics.get("Compensation Transparency", np.nan), 0, 1))
    G_scores.append(normalize(metrics.get("Anti-Corruption", np.nan), 0, 1))
    G_scores.append(normalize(metrics.get("Shareholder Rights", np.nan), 0, 1))
    G_scores.append(normalize(metrics.get("Whistleblower Program", np.nan), 0, 1))
    G_scores.append(normalize(metrics.get("Audit Risk Management", np.nan), 0, 1))

    G = np.nanmean(G_scores) * 100


    # --- OVERALL ESG SCORE ---
    ESG = round(0.4 * E + 0.3 * S + 0.3 * G, 2)

    return {
        "E": round(E, 2),
        "S": round(S, 2),
        "G": round(G, 2),
        "ESG Score": ESG
    }

sample_metrics = {
    "GHG Emissions": 120,  # tons CO2e
    "Energy Consumption": 45,  # GWh
    "Water Usage": 20,  # ML
    "Waste Recycling Rate": 80,  # %
    "Land Impact": 2,  # score 0-10
    "Environmental Policies": 1,  # 1 = present

    "Diversity Rate": 60,  # %
    "Labor Compliance": 1,
    "Injury Rate": 0.5,  # per 1000
    "Employee Training Hours": 50,
    "Community Programs": 1,
    "Data Privacy Score": 1,

    "Board Independence": 1,
    "Board Diversity": 0.7,
    "Compensation Transparency": 0.9,
    "Anti-Corruption": 1,
    "Shareholder Rights": 1,
    "Whistleblower Program": 1,
    "Audit Risk Management": 1
}

esg_result = compute_esg_advanced(sample_metrics)
print(esg_result)

import yfinance as yf
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# --- Stock List ---
tickers = {
    "TCS": "TCS.NS",
    "Infosys": "INFY.NS",
    "HDFC Bank": "HDFCBANK.NS",
    "ICICI Bank": "ICICIBANK.NS",
    "Kotak Mah. Bank": "KOTAKBANK.NS",
    "Hind. Unilever": "HINDUNILVR.NS",
    "ITC": "ITC.NS",
    "Nestle India": "NESTLEIND.NS",
    "Asian Paints": "ASIANPAINT.NS",
    "Tata Steel": "TATASTEEL.NS",
    "Tata Motors": "TATAMOTORS.NS",
    "Maruti Suzuki": "MARUTI.NS",
    "Reliance Industr": "RELIANCE.NS",
    "Adani Green": "ADANIGREEN.NS",
    "Power Grid Corpn": "POWERGRID.NS",
    "L&T Finance Ltd": "LTF.NS",
    "Larsen & Toubro": "LT.NS",
    "DLF": "DLF.NS",
    "Lodha Developers": "LODHA.NS",
    "Godrej Propert.": "GODREJPROP.NS",
    "Hindustan Zinc Ltd": "HINDZINC.NS",
    "Solar Industries India Ltd": "SOLARINDS.NS",
    "Max Healthcare Institute Ltd": "MAXHEALTH.NS",
    "HDFC Asset Management Company Ltd": "HDFCAMC.NS",
    "Union Bank of India Ltd": "UNIONBANK.NS",
    "Mankind Pharma Ltd": "MANKIND.NS",
    "Indus Towers Ltd": "INDUSTOWER.NS",
    "Muthoot Finance Ltd": "MUTHOOTFIN.NS",
    "Polycab India Ltd": "POLYCAB.NS",
    "Clean Science and Technology Ltd": "CLEAN.NS"
}

# --- Download Data ---
data = yf.download(list(tickers.values()), period="6mo")["Close"]
data = data.dropna(axis=1)
valid_tickers = [t for t, sym in tickers.items() if sym in data.columns]

# --- Returns and Volatility ---
returns = data.pct_change().dropna()
volatility = returns.std()
inv_vol = 1 / volatility
weights = inv_vol / inv_vol.sum()

# --- Entropy ---
def portfolio_entropy(weights):
    w = np.array(weights)
    w = w[w > 0]
    return -np.sum(w * np.log(w))

def stock_entropy_contribution(weights, tickers):
    contributions = {}
    for t, w in zip(tickers, weights):
        contributions[t] = -w * np.log(w) if w > 0 else 0
    return contributions

# --- Improved Buy/Sell Logic ---
def buy_sell_signal(weights, tickers):
    contrib = stock_entropy_contribution(weights, tickers)
    contrib_values = np.array(list(contrib.values()))
    mean_c = contrib_values.mean()
    std_c = contrib_values.std()

    signals = {}
    for stock, value in contrib.items():
        if value > mean_c + std_c * 0.5:
            signals[stock] = "BUY ‚úÖ"
        elif value < mean_c - std_c * 0.5:
            signals[stock] = "SELL ‚ùå"
        else:
            signals[stock] = "HOLD ‚öñÔ∏è"
    return signals, contrib

# --- Run Model ---
entropy_value = portfolio_entropy(weights)
signals, contrib = buy_sell_signal(weights, valid_tickers)

df_signals = pd.DataFrame({
    "Stock": valid_tickers,
    "Weight": weights.loc[data.columns].values,
    "Entropy Contribution": [contrib[t] for t in valid_tickers],
    "Signal": [signals[t] for t in valid_tickers]
})

# --- Display Results ---
print("\nüìä Portfolio Entropy:", round(entropy_value, 4), "\n")
print(df_signals.sort_values(by="Entropy Contribution", ascending=False).reset_index(drop=True))

# --- Visualization ---
plt.figure(figsize=(12,6))
bars = plt.bar(contrib.keys(), contrib.values(), edgecolor="black")
plt.xticks(rotation=45)
plt.ylabel("Entropy Contribution")
plt.title("Entropy-Based Buy/Hold/Sell Signals (Dynamic Threshold)")

for bar, stock in zip(bars, contrib.keys()):
    if signals[stock].startswith("BUY"):
        bar.set_color("green")
    elif signals[stock].startswith("SELL"):
        bar.set_color("red")
    else:
        bar.set_color("orange")

plt.tight_layout()
plt.show()

import yfinance as yf
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from xgboost import XGBClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix
import warnings
warnings.filterwarnings("ignore")

data = yf.download(list(tickers.values()), period="1y")["Close"].dropna(axis=1)
returns = data.pct_change().dropna()
volatility = returns.std()

# -----------------------------
# 2Ô∏è‚É£ Fundamental & Derived Metrics
# -----------------------------
features = []
for name, sym in tickers.items():
    info = yf.Ticker(sym).info
    pe = info.get("trailingPE", np.nan)
    div_yield = info.get("dividendYield", 0) * 100 if info.get("dividendYield") else 0
    mc = info.get("marketCap", 0) / 1e7
    np_qtr = info.get("netIncomeToCommon", 0) / 1e7
    sales = info.get("totalRevenue", 0) / 1e7
    vol = volatility.get(sym, np.nan)

    features.append({
        "Stock": name,
        "P/E": pe,
        "Div Yield %": div_yield,
        "Market Cap Cr": mc,
        "Net Profit Cr": np_qtr,
        "Sales Cr": sales,
        "Volatility": vol
    })

df = pd.DataFrame(features).dropna()

# -----------------------------
# 3Ô∏è‚É£ Entropy Feature
# -----------------------------
weights = 1 / df["Volatility"]
weights = weights / weights.sum()
df["Entropy Contribution"] = -weights * np.log(weights)

# -----------------------------
# 4Ô∏è‚É£ Label Creation (Buy / Hold / Sell)
# -----------------------------
mean_c = df["Entropy Contribution"].mean()
std_c = df["Entropy Contribution"].std()

def assign_label(x):
    if x > mean_c + 0.5 * std_c:
        return 1   # BUY
    elif x < mean_c - 0.5 * std_c:
        return -1  # SELL
    else:
        return 0   # HOLD

df["Signal"] = df["Entropy Contribution"].apply(assign_label)

# -----------------------------
# 5Ô∏è‚É£ Prepare Data for XGBoost
# -----------------------------
X = df[["P/E", "Div Yield %", "Market Cap Cr", "Net Profit Cr", "Sales Cr", "Volatility", "Entropy Contribution"]]
y = df["Signal"]

# Split data
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# -----------------------------
# 6Ô∏è‚É£ Train XGBoost Model
# -----------------------------
model = XGBClassifier(
    objective='multi:softmax',
    num_class=3,
    learning_rate=0.1,
    max_depth=3,
    n_estimators=100,
    subsample=0.8,
    colsample_bytree=0.8,
    random_state=42
)

model.fit(X_train, y_train)
y_pred = model.predict(X_test)

# -----------------------------
# 7Ô∏è‚É£ Evaluation
# -----------------------------
print("\nüìà Classification Report:\n", classification_report(y_test, y_pred, target_names=["SELL", "HOLD", "BUY"]))
print("Confusion Matrix:\n", confusion_matrix(y_test, y_pred))

# -----------------------------
# 8Ô∏è‚É£ Feature Importance
# -----------------------------
plt.figure(figsize=(8,5))
plt.barh(X.columns, model.feature_importances_, color="teal")
plt.title("Feature Importance (XGBoost)")
plt.xlabel("Importance Score")
plt.tight_layout()
plt.show()

# -----------------------------
# 9Ô∏è‚É£ Predict Current Stock Actions
# -----------------------------
df["Predicted Signal"] = model.predict(X)

signal_map = {-1: "SELL ‚ùå", 0: "HOLD ‚öñÔ∏è", 1: "BUY ‚úÖ"}
df["Predicted Action"] = df["Predicted Signal"].map(signal_map)

print("\nüîÆ XGBoost Stock Recommendations:\n")
print(df[["Stock", "P/E", "Div Yield %", "Market Cap Cr", "Volatility", "Predicted Action"]].reset_index(drop=True))

pip install yfinance pandas numpy scipy xgboost beautifulsoup4 requests scikit-learn

# portfolio_all_in_one.py
import time
import random
import math
import requests
from bs4 import BeautifulSoup
from datetime import datetime

import numpy as np
import pandas as pd
import yfinance as yf
from scipy.optimize import minimize
from xgboost import XGBClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix

# ------------------------
# User stock universe (change as needed)
# ------------------------
TICKERS = {
    "TCS": "TCS.NS", "Infosys": "INFY.NS", "HDFC Bank": "HDFCBANK.NS",
    "ICICI Bank": "ICICIBANK.NS", "Kotak Bank": "KOTAKBANK.NS",
    "Hind. Unilever": "HINDUNILVR.NS", "ITC": "ITC.NS", "Nestle India": "NESTLEIND.NS",
    "Asian Paints": "ASIANPAINT.NS", "Tata Steel": "TATASTEEL.NS", "Tata Motors": "TATAMOTORS.NS",
    "Maruti Suzuki": "MARUTI.NS", "Reliance": "RELIANCE.NS", "Adani Green": "ADANIGREEN.NS",
    "Power Grid": "POWERGRID.NS", "Larsen & Toubro": "LT.NS", "DLF": "DLF.NS",
    "Godrej Prop": "GODREJPROP.NS", "Hind Zinc": "HINDZINC.NS", "Polycab": "POLYCAB.NS"
}

# ------------------------
# Helper: fetch screener.in fields (used for ESG metrics)
# ------------------------
def fetch_screener_data(symbol_short):
    url = f"https://www.screener.in/company/{symbol_short}/consolidated/"
    headers = {"User-Agent": "Mozilla/5.0"}
    try:
        resp = requests.get(url, headers=headers, timeout=8)
        resp.raise_for_status()
        soup = BeautifulSoup(resp.text, "html.parser")
    except Exception:
        # return NaNs on failure
        return {k: np.nan for k in [
            "Promoter Holding %", "ROCE %", "ROE %", "Debt/Equity",
            "Qtr Profit Var %", "Qtr Sales Var %", "GHG", "Energy", "Water",
            "Waste Recycling Rate", "Board Independence"
        ]}

    data = {}
    mapping = [
        ("Promoter Holding %", ("Promoter holding", "%")),
        ("ROCE %", ("ROCE", "%")),
        ("ROE %", ("ROE %", "%")),
        ("Debt/Equity", ("Debt / Eq", "")),
        ("Qtr Profit Var %", ("Qtr Profit Var %", "%")),
        ("Qtr Sales Var %", ("Qtr Sales Var %", "%"))
    ]
    for field, label in mapping:
        try:
            node = soup.find(text=label[0])
            cell = node.find_next("td").text.strip()
            val = cell.replace("%", "").replace(",", "")
            data[field] = float(val)
        except Exception:
            data[field] = np.nan

    # Additional fields: best-effort placeholders (many companies won't have these on screener)
    # We'll attempt to read any labels for sustainability if present; else remain NaN
    # For this script, we'll leave climate metrics as NaN and fall back to heuristics later
    data["GHG"] = np.nan
    data["Energy"] = np.nan
    data["Water"] = np.nan
    data["Waste Recycling Rate"] = np.nan
    data["Board Independence"] = np.nan
    return data

# ------------------------
# Advanced ESG scorer (E, S, G composition) -- inputs may be NaN; function handles defaults
# ------------------------
def normalize(value, min_val, max_val):
    if value is None or (isinstance(value, float) and math.isnan(value)):
        return np.nan
    if max_val == min_val:
        return 0.5
    return float(max(0.0, min(1.0, (value - min_val) / (max_val - min_val))))

def compute_esg_advanced(metrics):
    # metrics is a dict containing available proxies
    # We'll create reasonable normalization ranges for proxies
    # Environmental proxies (lower is better for emissions/consumption)
    ghg = metrics.get("GHG", np.nan)            # tons CO2e (unknown)
    energy = metrics.get("Energy", np.nan)      # arbitrary units
    water = metrics.get("Water", np.nan)
    waste = metrics.get("Waste Recycling Rate", np.nan)  # percent
    env_policy = metrics.get("Environmental Policies", np.nan)  # 0/1

    # Social proxies
    diversity = metrics.get("Diversity Rate", np.nan)  # %
    labor_compliance = metrics.get("Labor Compliance", np.nan)  # 0/1
    injury_rate = metrics.get("Injury Rate", np.nan)  # incidents per thousand
    training_hours = metrics.get("Employee Training Hours", np.nan)
    community = metrics.get("Community Programs", np.nan)  # 0/1
    data_privacy = metrics.get("Data Privacy Score", np.nan)  # 0/1

    # Governance proxies
    board_ind = metrics.get("Board Independence", np.nan)  # 0-1
    board_div = metrics.get("Board Diversity", np.nan)  # 0-1
    comp_trans = metrics.get("Compensation Transparency", np.nan)  # 0-1
    anti_corr = metrics.get("Anti-Corruption", np.nan)  # 0-1
    shareholder = metrics.get("Shareholder Rights", np.nan)  # 0-1
    whistle = metrics.get("Whistleblower Program", np.nan)  # 0-1
    audit_rm = metrics.get("Audit Risk Management", np.nan)  # 0-1

    # Normalize with assumed reasonable ranges. If NaN, keep NaN so mean ignores them.
    E_list = []
    E_list.append(1 - normalize(ghg, 0, 1000))  # lower emissions -> better
    E_list.append(1 - normalize(energy, 0, 1000))
    E_list.append(1 - normalize(water, 0, 1000))
    E_list.append(normalize(waste, 0, 100))  # recycling %
    E_list.append(normalize(env_policy, 0, 1))

    S_list = []
    S_list.append(normalize(diversity, 0, 100))
    S_list.append(normalize(labor_compliance, 0, 1))
    S_list.append(1 - normalize(injury_rate, 0, 50))
    S_list.append(normalize(training_hours, 0, 200))
    S_list.append(normalize(community, 0, 1))
    S_list.append(normalize(data_privacy, 0, 1))

    G_list = []
    G_list.append(normalize(board_ind, 0, 1))
    G_list.append(normalize(board_div, 0, 1))
    G_list.append(normalize(comp_trans, 0, 1))
    G_list.append(normalize(anti_corr, 0, 1))
    G_list.append(normalize(shareholder, 0, 1))
    G_list.append(normalize(whistle, 0, 1))
    G_list.append(normalize(audit_rm, 0, 1))

    # Compute pillar means ignoring NaNs
    E = np.nanmean([x for x in E_list if not (isinstance(x, float) and math.isnan(x))])
    S = np.nanmean([x for x in S_list if not (isinstance(x, float) and math.isnan(x))])
    G = np.nanmean([x for x in G_list if not (isinstance(x, float) and math.isnan(x))])

    # If any pillar is nan (no data), fallback to neutral 0.5
    E = 0.5 if (E is None or math.isnan(E)) else E
    S = 0.5 if (S is None or math.isnan(S)) else S
    G = 0.5 if (G is None or math.isnan(G)) else G

    # Convert to 0-100 scale for readability
    E_score = round(E * 100, 2)
    S_score = round(S * 100, 2)
    G_score = round(G * 100, 2)
    ESG_score = round(0.4 * E_score + 0.3 * S_score + 0.3 * G_score, 2)
    return {"E": E_score, "S": S_score, "G": G_score, "ESG": ESG_score}

# ------------------------
# Black-Litterman helper
# ------------------------
def black_litterman(cov, pi, P=None, Q=None, tau=0.05, omega=None):
    cov = cov + np.eye(cov.shape[0]) * 1e-8
    if P is None or Q is None:
        return pi
    if omega is None:
        omega = np.diag(np.diag(P @ cov @ P.T)) * tau
    inv_tau_cov = np.linalg.inv(tau * cov)
    inv_omega = np.linalg.inv(omega)
    M = np.linalg.inv(inv_tau_cov + P.T @ inv_omega @ P)
    adj_return = M @ (inv_tau_cov @ pi + P.T @ inv_omega @ Q)
    return adj_return

# ------------------------
# Entropy & Nash bargaining
# ------------------------
def portfolio_entropy(weights):
    w = np.array(weights)
    w = w[w > 0]
    return -np.sum(w * np.log(w + 1e-12))

def stock_entropy_contribution(weights, labels):
    contributions = {}
    for t, w in zip(labels, weights):
        contributions[t] = float(-w * math.log(w + 1e-12)) if w > 0 else 0.0
    return contributions

def nash_bargaining(mu, cov, esg_scores):
    n = len(mu)
    init_w = np.ones(n) / n
    cons = ({'type': 'eq', 'fun': lambda w: np.sum(w) - 1})
    bounds = [(0, 1)] * n

    def utility(w):
        ret = float(np.dot(w, mu))
        risk = float(w @ cov @ w)
        esg = float(np.dot(w, esg_scores))
        ret = max(ret, 1e-9)
        risk = max(risk, 1e-9)
        esg = max(esg, 1e-9)
        return -(math.log(ret) + math.log(esg) - math.log(risk))

    res = minimize(utility, init_w, constraints=cons, bounds=bounds)
    return res.x if res.success else init_w

# ------------------------
# PEG calculator
# ------------------------
def calculate_peg_from_info(info):
    pe = info.get("trailingPE", np.nan)
    eps_ttm = info.get("trailingEps", np.nan)
    # attempt to compute simple earnings growth from quarterly earnings if available (best-effort)
    peg = np.nan
    try:
        # many tickers won't provide easy growth; fallback to NaN
        if pe is not None and eps_ttm is not None and not math.isnan(pe) and not math.isnan(eps_ttm) and eps_ttm != 0:
            # we can't compute growth without historical EPS easily; keep peg as NaN
            peg = np.nan
    except Exception:
        peg = np.nan
    return pe, peg

# ------------------------
# MAIN: dynamic pipeline run
# ------------------------
def run_pipeline(train_xgb=True):
    print("Starting pipeline:", datetime.now().isoformat())
    symbols = list(TICKERS.values())
    names = list(TICKERS.keys())

    # 1) Fetch Close price history (1 year)
    prices = yf.download(symbols, period="1y", threads=True)["Close"]
    # If single-column (1 ticker), make DataFrame
    if isinstance(prices, pd.Series):
        prices = prices.to_frame()

    # Drop symbols with missing data
    prices = prices.dropna(axis=1)
    available_symbols = list(prices.columns)
    available_names = [n for n, s in zip(names, symbols) if s in available_symbols]
    if len(available_symbols) == 0:
        raise RuntimeError("No price data available for the tickers. Check symbols or network.")

    # 2) Compute returns, mu, cov
    log_ret = np.log(prices / prices.shift(1)).dropna()
    mu = log_ret.mean().values * 252
    cov = log_ret.cov().values * 252

    # 3) Collect fundamentals + ESG scrapes
    rows = []
    esg_list = []
    pe_list = []
    peg_list = []
    vol_list = []
    for name, sym in zip(available_names, available_symbols):
        t = yf.Ticker(sym)
        info = {}
        try:
            info = t.info
        except Exception:
            info = {}
        pe, peg = calculate_peg_from_info(info)
        pe_list.append(np.nan if pe is None else pe)
        peg_list.append(np.nan if peg is None else peg)
        # fundamentals
        cur_price = prices[sym].iloc[-1] if sym in prices.columns else np.nan
        market_cap = info.get("marketCap", np.nan)
        div_yield = info.get("dividendYield", np.nan) * 100 if info.get("dividendYield") else np.nan
        net_income = info.get("netIncomeToCommon", np.nan)
        total_revenue = info.get("totalRevenue", np.nan)

        # vol
        vol = log_ret[sym].std() if sym in log_ret.columns else np.nan
        vol_list.append(vol)

        # Scrape screener for proxies
        short = sym.split(".")[0]
        scraped = fetch_screener_data(short)

        # Build rough metrics dict for ESG advanced function (we'll fill proxies)
        metrics = {}
        metrics.update(scraped)
        # Add a few heuristic proxies if screener missing:
        # - Environmental policy: assume True if company has green/ESG keywords in summary (best-effort)
        try:
            summary = info.get("longBusinessSummary", "").lower()
            metrics["Environmental Policies"] = 1.0 if ("environment" in summary or "sustainab" in summary) else 0.0
            metrics["Diversity Rate"] = info.get("diversity", np.nan)  # likely missing
        except Exception:
            metrics["Environmental Policies"] = np.nan
            metrics["Diversity Rate"] = np.nan

        esg_scores = compute_esg_advanced(metrics)
        esg_list.append(esg_scores["ESG"])

        rows.append({
            "Stock": name,
            "Symbol": sym,
            "Price": cur_price,
            "P/E": pe,
            "PEG": peg,
            "MarketCap": market_cap,
            "DivYield": div_yield,
            "NetIncome": net_income,
            "Revenue": total_revenue,
            "Volatility": vol,
            "E": esg_scores["E"],
            "S": esg_scores["S"],
            "G": esg_scores["G"],
            "ESG": esg_scores["ESG"]
        })

    df = pd.DataFrame(rows)
    df = df.reset_index(drop=True)

    # Map mu, cov ordering to df ordering: prices.columns corresponds to available_symbols (tickers)
    # Ensure mu, cov correspond to same order
    # We'll create ordering list to map mu entries to df rows
    symbol_to_index = {sym: i for i, sym in enumerate(available_symbols)}
    # reorder arrays to match df row order
    mu_ordered = np.array([mu[symbol_to_index[sym]] for sym in df["Symbol"]])
    cov_ordered = cov[[symbol_to_index[sym] for sym in df["Symbol"]]][:, [symbol_to_index[sym] for sym in df["Symbol"]]]

    # 4) Black-Litterman: simple prior = mu; sample view: small positive on top 2 market caps
    # find top 2 by market cap
    try:
        top_idx = df["MarketCap"].nlargest(2).index.tolist()
        P = np.zeros((1, len(df)))
        for ii in top_idx:
            P[0, ii] = 1/len(top_idx)
        Q = np.array([0.08])  # target excess return
        bl_mu = black_litterman(cov_ordered, mu_ordered, P=P, Q=Q, tau=0.05)
    except Exception:
        bl_mu = mu_ordered

    # 5) Entropy-based weights (blend inv-vol + fundamental strength)
    # compute inv vol safely
    df["Volatility"] = df["Volatility"].fillna(df["Volatility"].mean() if df["Volatility"].notna().any() else 0.01)
    inv_vol = 1.0 / (df["Volatility"].replace(0, 1e-6))
    inv_vol = inv_vol / inv_vol.sum()

    # fundamental strength: normalize PE (lower better), DivYield higher better, NetIncome, Revenue
    def safe_norm(s):
        if s.isnull().all():
            return pd.Series([0.5]*len(s), index=s.index)
        return (s.fillna(s.median()) - s.fillna(s.median()).min()) / (s.fillna(s.median()).max() - s.fillna(s.median()).min() + 1e-9)
    pe_norm = 1 - safe_norm(df["P/E"])
    div_norm = safe_norm(df["DivYield"].fillna(0))
    profit_norm = safe_norm(df["NetIncome"].fillna(0))
    sales_norm = safe_norm(df["Revenue"].fillna(0))
    price_norm = 1 - safe_norm(df["Price"].fillna(df["Price"].median()))

    df["Fundamental_Strength"] = 0.2*pe_norm + 0.2*div_norm + 0.25*profit_norm + 0.25*sales_norm + 0.1*price_norm
    fund_strength = df["Fundamental_Strength"].fillna(df["Fundamental_Strength"].mean())
    fund_strength = fund_strength / fund_strength.sum()

    # blend
    weights = 0.5*inv_vol.values + 0.5*fund_strength.values
    weights = weights / weights.sum()
    df["EntropyWeight"] = weights

    # entropy contributions
    contrib = stock_entropy_contribution(weights, df["Stock"].tolist())
    df["EntropyContribution"] = df["Stock"].map(contrib)

    # 6) Game theory (Nash bargaining) weights using BL mu, cov and ESG (normalized)
    esg_norm = (df["ESG"].fillna(df["ESG"].mean()) - df["ESG"].min()) / (df["ESG"].max() - df["ESG"].min() + 1e-9)
    gt_weights = nash_bargaining(bl_mu, cov_ordered, esg_norm.values)
    df["GT_Weight"] = gt_weights

    # 7) Combine strategies: equal blend of BL signal, Entropy, GT -> produce final weights
    # Normalize bl_mu to positive scale to convert to weights via softmax
    def softmax(x):
        ex = np.exp(x - np.nanmax(x))
        return ex / (np.nansum(ex) + 1e-12)
    mu_shaped = softmax(bl_mu)
    df["BL_Weight"] = mu_shaped / mu_shaped.sum()
    final_weights = 0.33*df["EntropyWeight"].values + 0.34*df["BL_Weight"].values + 0.33*df["GT_Weight"].values
    final_weights = final_weights / final_weights.sum()
    df["FinalWeight"] = final_weights

    # 8) Decision rule (blended with ESG):
    tertiles = np.percentile(df["FinalWeight"].values, [33.33, 66.66])
    def decision_rule(row):
        esg_sig = "BUY" if row["ESG"] >= 70 else ("HOLD" if row["ESG"] >= 40 else "SELL")
        if row["FinalWeight"] >= tertiles[1]:
            weight_sig = "BUY"
        elif row["FinalWeight"] >= tertiles[0]:
            weight_sig = "HOLD"
        else:
            weight_sig = "SELL"
        if esg_sig == weight_sig:
            return esg_sig
        else:
            # prefer ESG but soften extremes
            if esg_sig == "SELL" and weight_sig == "BUY":
                return "HOLD"
            return esg_sig

    df["Signal"] = df.apply(decision_rule, axis=1)

    # 9) Prepare features for XGBoost
    df["PE_filled"] = df["P/E"].fillna(df["P/E"].median())
    df["Div_filled"] = df["DivYield"].fillna(0.0)
    df["MarketCap_filled"] = df["MarketCap"].fillna(df["MarketCap"].median())
    df["NetIncome_filled"] = df["NetIncome"].fillna(0.0)
    df["Revenue_filled"] = df["Revenue"].fillna(0.0)
    df["Vol_filled"] = df["Volatility"].fillna(df["Volatility"].mean())

    feature_cols = [
        "PE_filled", "Div_filled", "MarketCap_filled",
        "NetIncome_filled", "Revenue_filled", "Vol_filled",
        "EntropyContribution", "E", "S", "G", "BL_Weight"
    ]
    # create features matrix
    X = df[feature_cols].copy().fillna(0)
    # label mapping: BUY=1, HOLD=0, SELL=-1 -> map to 0,1,2 for xgb multiclass
    label_map = {"SELL": 0, "HOLD": 1, "BUY": 2}
    y = df["Signal"].map(label_map).astype(int)

    # 10) Train XGBoost if enough samples
    df["PredictedSignal"] = df["Signal"]  # default fallback
    df["PredictedProb"] = None
    if train_xgb and len(df) >= 6:
        try:
            X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42, stratify=y if len(np.unique(y))>1 else None)
            model = XGBClassifier(
                objective='multi:softprob',
                num_class=3,
                learning_rate=0.1,
                max_depth=4,
                n_estimators=200,
                subsample=0.9,
                colsample_bytree=0.8,
                use_label_encoder=False,
                eval_metric='mlogloss',
                random_state=42
            )
            model.fit(X_train, y_train)
            y_pred = model.predict(X_test)
            print("\nXGBoost classification report:")
            print(classification_report(y_test, y_pred, target_names=["SELL","HOLD","BUY"]))
            # Predict on full dataset
            preds = model.predict(X)
            probs = model.predict_proba(X).max(axis=1)
            inv_label_map = {v:k for k,v in label_map.items()}
            df["PredictedSignal"] = [inv_label_map.get(int(p), "HOLD") for p in preds]
            df["PredictedProb"] = probs
        except Exception as e:
            print("XGBoost training failed, using rule-based signals. Error:", e)
    else:
        print("Skipping XGBoost training (not enough samples). Using rule-based signals.")

    # 11) Final recommendation: combine model prediction and rule-based blended signal
    def final_recommend(row):
        rule = row["Signal"]
        model_pred = row["PredictedSignal"]
        prob = row["PredictedProb"] if row["PredictedProb"] is not None else 0.0
        # if model trained and confident (>0.6), trust model else trust rule (ESG+weights)
        if model_pred is not None and prob is not None and prob > 0.6:
            return model_pred + " (model)"
        return rule + " (rule)"

    df["FinalRecommendation"] = df.apply(final_recommend, axis=1)

    # Sort and display
    out = df[[
        "Stock","Symbol","Price","P/E","PEG","MarketCap","DivYield","NetIncome","Revenue",
        "Volatility","E","S","G","ESG","EntropyWeight","EntropyContribution",
        "GT_Weight","BL_Weight","FinalWeight","Signal","PredictedSignal","PredictedProb","FinalRecommendation"
    ]].sort_values(by="FinalWeight", ascending=False).reset_index(drop=True)

    print("\nPipeline finished:", datetime.now().isoformat())
    return out

# ------------------------
# Run
# ------------------------
if __name__ == "__main__":
    portfolio_df = run_pipeline(train_xgb=True)
    pd.set_option("display.max_columns", None)
    print("\n=== Final Recommendations ===\n")
    print(portfolio_df.head(40).to_string(index=False))

# Commented out IPython magic to ensure Python compatibility.
# %pip install streamlit

import yfinance as yf
import numpy as np
import pandas as pd
from sklearn.naive_bayes import GaussianNB
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.metrics import accuracy_score, classification_report
import matplotlib.pyplot as plt
import seaborn as sns


data = yf.download(list(tickers.values()), period="6mo")["Close"]
returns = data.pct_change().dropna()
volatility = returns.std()
inv_vol = 1 / volatility
weights = inv_vol / inv_vol.sum()

df = pd.DataFrame({
    "Stock": list(tickers.keys()),
    "Symbol": list(tickers.values()),
    "Volatility": volatility.values,
    "Weight": weights.values
})

info_list = []
for sym in tickers.values():
    info = yf.Ticker(sym).info
    pe = info.get("trailingPE", np.nan)
    div = info.get("dividendYield", np.nan)
    price = info.get("currentPrice", np.nan)
    mc = info.get("marketCap", np.nan)
    info_list.append([price, pe, div, mc])
extra = pd.DataFrame(info_list, columns=["Price", "PE", "DivYield", "MCap"])
df = pd.concat([df, extra], axis=1)

def classify_signal(row):
    if row["Weight"] > df["Weight"].mean()*1.1 and (row["PE"] < df["PE"].mean() or row["DivYield"] > df["DivYield"].mean()):
        return "BUY"
    elif row["Weight"] < df["Weight"].mean()*0.9:
        return "SELL"
    else:
        return "HOLD"

df["Signal"] = df.apply(classify_signal, axis=1)

features = ["Volatility", "Weight", "PE", "DivYield", "Price", "MCap"]
df = df.dropna(subset=features)

le = LabelEncoder()
y = le.fit_transform(df["Signal"])
X = df[features].values
X = np.nan_to_num(X)

scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.3, random_state=42)
model = GaussianNB()
model.fit(X_train, y_train)
y_pred = model.predict(X_test)

print("Accuracy:", round(accuracy_score(y_test, y_pred), 3))
print(classification_report(y_test, y_pred, target_names=le.classes_))

df["Predicted"] = le.inverse_transform(model.predict(X_scaled))
plt.figure(figsize=(8,4))
sns.countplot(x="Predicted", data=df, palette="coolwarm")
plt.title("Naive Bayes Predicted Signals (Live Data)")
plt.show()

print(df[["Stock", "Signal", "Predicted", "Weight", "PE", "DivYield"]])

!pip install pypfopt

import numpy as np
import pandas as pd
import yfinance as yf
from pypfopt import risk_models, expected_returns, black_litterman
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.naive_bayes import GaussianNB
from xgboost import XGBClassifier
from sklearn.metrics import accuracy_score, classification_report

# ---- Fetch Live Data ----

data = yf.download(tickers, start="2023-01-01", end="2025-10-01")

# Handle missing 'Adj Close'
prices = data['Adj Close'] if 'Adj Close' in data.columns else data['Close']
prices = prices.dropna()
returns = prices.pct_change().dropna()

# ---- Black-Litterman Model ----
mu = expected_returns.mean_historical_return(prices)
S = risk_models.sample_cov(prices)
market_prior = mu
P = np.eye(len(tickers))
Q = mu.values * 1.05
bl = black_litterman.BlackLittermanModel(S, pi=market_prior, P=P, Q=Q)
bl_returns = bl.bl_returns()
bl_cov = bl.bl_cov()

# ---- Entropy Weights (per stock) ----
def entropy_weights(df):
    df = np.abs(df) + 1e-9
    norm_df = df / df.sum()
    e = - (norm_df * np.log(norm_df)).sum()
    w = (1 - e / np.log(len(df)))
    return w / w.sum()

entropy_weight = entropy_weights(returns)

# ---- ESG Dummy Data ----
esg_scores = np.random.randint(50, 90, len(tickers))
esg_df = pd.DataFrame({"Ticker": tickers, "ESG_Score": esg_scores})

# ---- Combine into one DataFrame ----
df = pd.DataFrame({
    "Ticker": tickers,
    "Expected_Return": bl_returns.values,
    "Volatility": np.sqrt(np.diag(bl_cov)),
    "Entropy_Weight": entropy_weight.values,
    "ESG_Score": esg_scores,
    "Momentum": returns.mean().values * 252
})

df["Risk_Adjusted_Return"] = df["Expected_Return"] / df["Volatility"]
df["Target"] = np.where(df["Risk_Adjusted_Return"] > df["Risk_Adjusted_Return"].median(), 1, 0)

# ---- Handle Missing Data ----
df = df.fillna(df.mean(numeric_only=True))

# ---- Train/Test Split ----
features = ["Expected_Return", "Volatility", "Entropy_Weight", "ESG_Score", "Momentum", "Risk_Adjusted_Return"]
X = df[features].values
y = df["Target"].values

sc = StandardScaler()
X_scaled = sc.fit_transform(X)
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.3, random_state=42)

# ---- Naive Bayes ----
nb = GaussianNB()
nb.fit(X_train, y_train)
y_pred_nb = nb.predict(X_test)

# ---- XGBoost ----
xgb = XGBClassifier(use_label_encoder=False, eval_metric="mlogloss")
xgb.fit(X_train, y_train)
y_pred_xgb = xgb.predict(X_test)

# ---- Combine Predictions (Game Theory: Voting) ----
final_pred = np.round((y_pred_nb + y_pred_xgb) / 2)

# ---- Results ----
print("Naive Bayes Accuracy:", accuracy_score(y_test, y_pred_nb))
print("XGBoost Accuracy:", accuracy_score(y_test, y_pred_xgb))
print("Combined Model Accuracy:", accuracy_score(y_test, final_pred))
print("\nClassification Report:\n", classification_report(y_test, final_pred))

df["Recommendation"] = np.where(df["Target"] == 1, "BUY", "HOLD/SELL")
print("\nFinal Recommendations:\n", df[["Ticker", "Recommendation", "Expected_Return", "ESG_Score"]])

import numpy as np
import pandas as pd
import yfinance as yf
from pypfopt import risk_models, expected_returns, black_litterman
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.svm import SVC
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
import seaborn as sns
import matplotlib.pyplot as plt

# ---- Fetch Live Data ----
# Download historical price data for the defined tickers
data = yf.download(list(tickers.values()), period="6mo")

# Handle missing 'Adj Close'
prices = data['Adj Close'] if 'Adj Close' in data.columns else data['Close']
prices = prices.dropna()
returns = prices.pct_change().dropna()

# ---- Black-Litterman Model ----
mu = expected_returns.mean_historical_return(prices)
S = risk_models.sample_cov(prices)
market_prior = mu
# Create identity matrix P and adjusted Q for a simple view (e.g., slight increase in expected returns)
P = np.eye(len(tickers))
Q = mu.values * 1.05
bl = black_litterman.BlackLittermanModel(S, pi=market_prior, P=P, Q=Q)
bl_returns = bl.bl_returns()
bl_cov = bl.bl_cov()

# ---- Entropy Weights (per stock) ----
def entropy_weights(returns_series):
    # Calculate weights based on inverse volatility
    volatility = returns_series.std()
    inv_vol = 1 / volatility
    weights = inv_vol / inv_vol.sum()
    return weights


entropy_wts = entropy_weights(returns)

# ---- ESG Dummy Data ----
# Generate dummy ESG scores for the tickers
esg_scores = np.random.randint(50, 90, len(tickers))


# ---- Combine All Factors ----
# Create a DataFrame to hold all calculated and dummy data
df_combined = pd.DataFrame({
    "Ticker": list(tickers.values()),
    "Expected_Return": bl_returns.values,
    "Volatility": np.sqrt(np.diag(bl_cov)),
    "Entropy_Weight": entropy_wts.values, # Use the calculated entropy weights
    "ESG_Score": esg_scores,
    "Momentum": returns.mean().values * 252 # Calculate momentum from historical returns
})

# Calculate Risk-Adjusted Return (e.g., Sharpe Ratio proxy)
df_combined["Risk_Adjusted_Return"] = df_combined["Expected_Return"] / df_combined["Volatility"]
# Define a target variable based on Risk-Adjusted Return (e.g., above median is 'BUY')
df_combined["Target"] = np.where(df_combined["Risk_Adjusted_Return"] > df_combined["Risk_Adjusted_Return"].median(), 1, 0)

# ---- Prepare Data ----
# Select features for the SVM model
features = ["Expected_Return", "Volatility", "Entropy_Weight", "ESG_Score", "Momentum", "Risk_Adjusted_Return"]
X = df_combined[features].values
y = df_combined["Target"].values

# Scale the features
sc = StandardScaler()
X_scaled = sc.fit_transform(X)
# Split data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.3, random_state=42)

# ---- Train SVM ----
# Initialize and train the Support Vector Machine model
svm = SVC(kernel='rbf', C=1, gamma='auto', probability=True) # Added probability=True for potential future use
svm.fit(X_train, y_train)
# Make predictions on the test set
y_pred = svm.predict(X_test)

# ---- Evaluation ----
# Evaluate the model's performance
print("SVM Accuracy:", accuracy_score(y_test, y_pred))
print("\nClassification Report:\n", classification_report(y_test, y_pred))

# Plot the confusion matrix
cm = confusion_matrix(y_test, y_pred)
sns.heatmap(cm, annot=True, fmt='d', cmap='coolwarm', xticklabels=["Hold/Sell", "Buy"], yticklabels=["Hold/Sell", "Buy"])
plt.title("SVM Confusion Matrix")
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.show()

# ---- Final Recommendation ----
# Predict the signal for all stocks in the combined DataFrame
df_combined["Predicted_Signal"] = svm.predict(X_scaled)
# Map the predicted signal to a human-readable recommendation
df_combined["Recommendation"] = np.where(df_combined["Predicted_Signal"] == 1, "BUY ‚úÖ", "HOLD/SELL ‚öñÔ∏è")
# Print the final recommendations
print("\nFinal Stock Recommendations:")
print(df_combined[["Ticker", "Expected_Return", "Volatility", "ESG_Score", "Recommendation"]])

import numpy as np
import pandas as pd
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import DBSCAN
import matplotlib.pyplot as plt
import seaborn as sns

# Assume df already exists and has these columns:
# ["Ticker", "Expected_Return", "Volatility", "Entropy_Weight", "ESG_Score", "Momentum", "Risk_Adjusted_Return"]

# --- Step 1: Select Features ---
features = ["Expected_Return", "Volatility", "Entropy_Weight", "ESG_Score", "Momentum", "Risk_Adjusted_Return"]
X = df_combined[features].copy()

# --- Step 2: Scale Data ---
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# --- Step 3: Apply DBSCAN ---
# eps = neighborhood radius, min_samples = min points to form a dense region
dbscan = DBSCAN(eps=0.8, min_samples=2)
clusters = dbscan.fit_predict(X_scaled)

# --- Step 4: Add Cluster Labels to DataFrame ---
df_combined["Cluster"] = clusters

# --- Step 5: Interpret Clusters ---
# -1 = noise (outliers)
cluster_summary = df_combined.groupby("Cluster")[features].mean().round(4)
print("\n=== DBSCAN Cluster Summary ===")
print(cluster_summary)

# --- Step 6: Visualize Clusters ---
plt.figure(figsize=(10,6))
sns.scatterplot(
    data=df_combined,
    x="Expected_Return",
    y="Volatility",
    hue="Cluster",
    palette="tab10",
    s=100,
    edgecolor="black"
)
plt.title("DBSCAN Clustering: Expected Return vs Volatility")
plt.xlabel("Expected Return")
plt.ylabel("Volatility")
plt.legend(title="Cluster")
plt.show()

# --- Step 7: Identify Outliers ---
outliers = df_combined[df_combined["Cluster"] == -1]
print("\nüìâ Potential Outlier Stocks:")
print(outliers[["Ticker", "Expected_Return", "Volatility", "ESG_Score", "Risk_Adjusted_Return"]])

# --- Step 8: Optional Recommendation Logic ---
def dbscan_signal(row):
    if row["Cluster"] == -1:
        return "CAUTION ‚ö†Ô∏è (Outlier)"
    elif row["Expected_Return"] > df_combined["Expected_Return"].median() and row["ESG_Score"] > df_combined["ESG_Score"].median():
        return "BUY ‚úÖ"
    else:
        return "HOLD/SELL ‚öñÔ∏è"

df_combined["DBSCAN_Signal"] = df_combined.apply(dbscan_signal, axis=1)

print("\n=== Final Recommendations (DBSCAN-based) ===")
print(df_combined[["Ticker", "Cluster", "Expected_Return", "Volatility", "ESG_Score", "DBSCAN_Signal"]])

# ---- LSTM for Time Series Forecasting ----

import numpy as np
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
import matplotlib.pyplot as plt

# ---- STEP 1: Prepare Data ----
# Example: using 'Close' column for a specific stock (e.g., TCS)
# Use the 'prices' DataFrame which contains the historical Close prices
# Select the data for a single stock (e.g., TCS.NS)
stock_symbol_for_lstm = 'TCS.NS' # Choose a stock to forecast
if stock_symbol_for_lstm not in prices.columns:
    raise ValueError(f"Stock symbol {stock_symbol_for_lstm} not found in prices data.")

stock_prices = prices[[stock_symbol_for_lstm]].values

# Scale data between 0 and 1
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(stock_prices)

# Function to create sequences
def create_sequences(data, time_step=60):
    X, y = [], []
    for i in range(len(data) - time_step): # Corrected loop range
        X.append(data[i:(i + time_step), 0]) # Assuming price is the first column
        y.append(data[i + time_step, 0])    # Assuming price is the first column
    return np.array(X), np.array(y)

# Create sequences (use 60 previous values to predict next one)
time_step = 60
X, y = create_sequences(scaled_data, time_step)


# Reshape for LSTM [samples, time_steps, features]
# Adjust the reshape based on the number of features used, currently 1 (Close price)
X = X.reshape(X.shape[0], X.shape[1], 1)


# ---- STEP 2: Split Data ----
train_size = int(len(X) * 0.8)
X_train, X_test = X[:train_size], X[train_size:]
y_train, y_test = y[:train_size], y[train_size:]

# ---- STEP 3: Build LSTM Model ----
model = Sequential([
    LSTM(100, return_sequences=True, input_shape=(time_step, 1)),
    Dropout(0.2),
    LSTM(100, return_sequences=False),
    Dropout(0.2),
    Dense(50, activation='relu'),
    Dense(1)
])

model.compile(optimizer='adam', loss='mean_squared_error')

# ---- STEP 4: Train ----
history = model.fit(X_train, y_train, epochs=30, batch_size=32, validation_data=(X_test, y_test), verbose=1)


# ---- STEP 5: Predictions ----
train_predict = model.predict(X_train)
test_predict = model.predict(X_test)

# Inverse transform predictions
train_predict = scaler.inverse_transform(train_predict)
test_predict = scaler.inverse_transform(test_predict)

# ---- STEP 6: Plot ----
plt.figure(figsize=(10,6))

# Create time indices for plotting
# The first prediction corresponds to time_step index in the original data
train_predict_index = prices.index[time_step : time_step + len(train_predict)]
test_predict_index = prices.index[time_step + len(train_predict) : time_step + len(train_predict) + len(test_predict)]


# Plot actual data (shifted to align with predictions)
# The actual data points being predicted start from index time_step
plt.plot(prices.index[time_step:], stock_prices[time_step:], label='Actual Data (Aligned)', color='blue')

# Plot training predictions
plt.plot(train_predict_index, train_predict, label='Train Prediction', color='orange')

# Plot testing predictions
plt.plot(test_predict_index, test_predict, label='Test Prediction', color='green')


plt.title(f'LSTM Prediction for {stock_symbol_for_lstm}')
plt.xlabel('Date')
plt.ylabel('Price')
plt.legend()
plt.show()

import matplotlib.pyplot as plt

# ---- Replace with your actual accuracies ----
accuracies = {
    'SVM': 0.82,
    'DBSCAN': 0.68,
    'LSTM': 0.91
}

# Extract names and values
models = list(accuracies.keys())
scores = list(accuracies.values())

# ---- Line Graph ----
plt.figure(figsize=(8,5))
plt.plot(models, scores, marker='o', linestyle='-', color='royalblue', linewidth=2)

# Annotate points
for i, score in enumerate(scores):
    plt.text(i, score + 0.01, f"{score*100:.1f}%", ha='center', fontsize=10, color='black')

plt.title("Model Accuracy Comparison: SVM vs DBSCAN vs LSTM", fontsize=14, fontweight='bold')
plt.xlabel("Model", fontsize=12)
plt.ylabel("Accuracy", fontsize=12)
plt.ylim(0, 1.1)
plt.grid(True, linestyle='--', alpha=0.6)
plt.show()